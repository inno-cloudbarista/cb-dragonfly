// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cbdragonfly/cbdragonfly.proto

package cbdragonfly

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cloud-barista/cb-spider/api-runtime/grpc-runtime/stub/gogoproto"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Empty 메시지 정의
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// MessageResponse 응답 메시지 정의
type MessageResponse struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message" yaml:"message"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageResponse) Reset()         { *m = MessageResponse{} }
func (m *MessageResponse) String() string { return proto.CompactTextString(m) }
func (*MessageResponse) ProtoMessage()    {}
func (*MessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{1}
}
func (m *MessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageResponse.Merge(m, src)
}
func (m *MessageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MessageResponse proto.InternalMessageInfo

func (m *MessageResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type Tags struct {
	//	string host_id = 1 [json_name="hostId", (gogoproto.jsontag) = "hostId", (gogoproto.moretags) = "yaml:\"hostId\""];
	NsId                 string   `protobuf:"bytes,1,opt,name=ns_id,json=nsId,proto3" json:"nsId" yaml:"nsId"`
	McisId               string   `protobuf:"bytes,2,opt,name=mcis_id,json=mcisId,proto3" json:"mcisId" yaml:"mcisId"`
	VmId                 string   `protobuf:"bytes,3,opt,name=vm_id,json=vmId,proto3" json:"vmId" yaml:"vmId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tags) Reset()         { *m = Tags{} }
func (m *Tags) String() string { return proto.CompactTextString(m) }
func (*Tags) ProtoMessage()    {}
func (*Tags) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{2}
}
func (m *Tags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tags.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tags.Merge(m, src)
}
func (m *Tags) XXX_Size() int {
	return m.Size()
}
func (m *Tags) XXX_DiscardUnknown() {
	xxx_messageInfo_Tags.DiscardUnknown(m)
}

var xxx_messageInfo_Tags proto.InternalMessageInfo

func (m *Tags) GetNsId() string {
	if m != nil {
		return m.NsId
	}
	return ""
}

func (m *Tags) GetMcisId() string {
	if m != nil {
		return m.McisId
	}
	return ""
}

func (m *Tags) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

type VMMonQryRequest struct {
	NsId                 string   `protobuf:"bytes,1,opt,name=ns_id,proto3" json:"ns_id" yaml:"ns_id"`
	McisId               string   `protobuf:"bytes,2,opt,name=mcis_id,proto3" json:"mcis_id" yaml:"mcis_id"`
	VmId                 string   `protobuf:"bytes,3,opt,name=vm_id,proto3" json:"vm_id" yaml:"vm_id"`
	PeriodType           string   `protobuf:"bytes,4,opt,name=period_type,json=periodType,proto3" json:"periodType" yaml:"periodType"`
	StatisticsCriteria   string   `protobuf:"bytes,5,opt,name=statistics_criteria,json=statisticsCriteria,proto3" json:"statisticsCriteria" yaml:"statisticsCriteria"`
	Duration             string   `protobuf:"bytes,6,opt,name=duration,proto3" json:"duration" yaml:"duration"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VMMonQryRequest) Reset()         { *m = VMMonQryRequest{} }
func (m *VMMonQryRequest) String() string { return proto.CompactTextString(m) }
func (*VMMonQryRequest) ProtoMessage()    {}
func (*VMMonQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{3}
}
func (m *VMMonQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VMMonQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VMMonQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VMMonQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VMMonQryRequest.Merge(m, src)
}
func (m *VMMonQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *VMMonQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VMMonQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VMMonQryRequest proto.InternalMessageInfo

func (m *VMMonQryRequest) GetNsId() string {
	if m != nil {
		return m.NsId
	}
	return ""
}

func (m *VMMonQryRequest) GetMcisId() string {
	if m != nil {
		return m.McisId
	}
	return ""
}

func (m *VMMonQryRequest) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

func (m *VMMonQryRequest) GetPeriodType() string {
	if m != nil {
		return m.PeriodType
	}
	return ""
}

func (m *VMMonQryRequest) GetStatisticsCriteria() string {
	if m != nil {
		return m.StatisticsCriteria
	}
	return ""
}

func (m *VMMonQryRequest) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

type VMOndemandMonQryRequest struct {
	NsId                 string   `protobuf:"bytes,1,opt,name=ns_id,proto3" json:"ns_id" yaml:"ns_id"`
	McisId               string   `protobuf:"bytes,2,opt,name=mcis_id,proto3" json:"mcis_id" yaml:"mcis_id"`
	VmId                 string   `protobuf:"bytes,3,opt,name=vm_id,proto3" json:"vm_id" yaml:"vm_id"`
	AgentIp              string   `protobuf:"bytes,4,opt,name=agent_ip,proto3" json:"agent_ip" yaml:"agent_ip"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VMOndemandMonQryRequest) Reset()         { *m = VMOndemandMonQryRequest{} }
func (m *VMOndemandMonQryRequest) String() string { return proto.CompactTextString(m) }
func (*VMOndemandMonQryRequest) ProtoMessage()    {}
func (*VMOndemandMonQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{4}
}
func (m *VMOndemandMonQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VMOndemandMonQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VMOndemandMonQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VMOndemandMonQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VMOndemandMonQryRequest.Merge(m, src)
}
func (m *VMOndemandMonQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *VMOndemandMonQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VMOndemandMonQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VMOndemandMonQryRequest proto.InternalMessageInfo

func (m *VMOndemandMonQryRequest) GetNsId() string {
	if m != nil {
		return m.NsId
	}
	return ""
}

func (m *VMOndemandMonQryRequest) GetMcisId() string {
	if m != nil {
		return m.McisId
	}
	return ""
}

func (m *VMOndemandMonQryRequest) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

func (m *VMOndemandMonQryRequest) GetAgentIp() string {
	if m != nil {
		return m.AgentIp
	}
	return ""
}

type VMLatestMonQryRequest struct {
	NsId                 string   `protobuf:"bytes,1,opt,name=ns_id,proto3" json:"ns_id" yaml:"ns_id"`
	McisId               string   `protobuf:"bytes,2,opt,name=mcis_id,proto3" json:"mcis_id" yaml:"mcis_id"`
	VmId                 string   `protobuf:"bytes,3,opt,name=vm_id,proto3" json:"vm_id" yaml:"vm_id"`
	StatisticsCriteria   string   `protobuf:"bytes,4,opt,name=statistics_criteria,json=statisticsCriteria,proto3" json:"statisticsCriteria" yaml:"statisticsCriteria"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VMLatestMonQryRequest) Reset()         { *m = VMLatestMonQryRequest{} }
func (m *VMLatestMonQryRequest) String() string { return proto.CompactTextString(m) }
func (*VMLatestMonQryRequest) ProtoMessage()    {}
func (*VMLatestMonQryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{5}
}
func (m *VMLatestMonQryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VMLatestMonQryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VMLatestMonQryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VMLatestMonQryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VMLatestMonQryRequest.Merge(m, src)
}
func (m *VMLatestMonQryRequest) XXX_Size() int {
	return m.Size()
}
func (m *VMLatestMonQryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VMLatestMonQryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VMLatestMonQryRequest proto.InternalMessageInfo

func (m *VMLatestMonQryRequest) GetNsId() string {
	if m != nil {
		return m.NsId
	}
	return ""
}

func (m *VMLatestMonQryRequest) GetMcisId() string {
	if m != nil {
		return m.McisId
	}
	return ""
}

func (m *VMLatestMonQryRequest) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

func (m *VMLatestMonQryRequest) GetStatisticsCriteria() string {
	if m != nil {
		return m.StatisticsCriteria
	}
	return ""
}

//////////////////////////////////
// VM 온디멘드 모니터링 메시지 정의 (CPU 메트릭)
//////////////////////////////////
type CpuOndemandInfoResponse struct {
	Name                 string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags              `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Time                 string             `protobuf:"bytes,3,opt,name=time,proto3" json:"time" yaml:"time"`
	Values               []*CpuOndemandInfo `protobuf:"bytes,4,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CpuOndemandInfoResponse) Reset()         { *m = CpuOndemandInfoResponse{} }
func (m *CpuOndemandInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CpuOndemandInfoResponse) ProtoMessage()    {}
func (*CpuOndemandInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{6}
}
func (m *CpuOndemandInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuOndemandInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuOndemandInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuOndemandInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuOndemandInfoResponse.Merge(m, src)
}
func (m *CpuOndemandInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CpuOndemandInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuOndemandInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpuOndemandInfoResponse proto.InternalMessageInfo

func (m *CpuOndemandInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CpuOndemandInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *CpuOndemandInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *CpuOndemandInfoResponse) GetValues() []*CpuOndemandInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type CpuOndemandInfo struct {
	CpuUtilization       float64  `protobuf:"fixed64,1,opt,name=cpu_utilization,proto3" json:"cpu_utilization" yaml:"cpu_utilization"`
	CpuSystem            float64  `protobuf:"fixed64,2,opt,name=cpu_system,proto3" json:"cpu_system" yaml:"cpu_system"`
	CpuIdle              float64  `protobuf:"fixed64,3,opt,name=cpu_idle,proto3" json:"cpu_idle" yaml:"cpu_idle"`
	CpuIowait            float64  `protobuf:"fixed64,4,opt,name=cpu_iowait,proto3" json:"cpu_iowait" yaml:"cpu_iowait"`
	CpuHintr             float64  `protobuf:"fixed64,5,opt,name=cpu_hintr,proto3" json:"cpu_hintr" yaml:"cpu_hintr"`
	CpuSintr             float64  `protobuf:"fixed64,6,opt,name=cpu_sintr,proto3" json:"cpu_sintr" yaml:"cpu_sintr"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuOndemandInfo) Reset()         { *m = CpuOndemandInfo{} }
func (m *CpuOndemandInfo) String() string { return proto.CompactTextString(m) }
func (*CpuOndemandInfo) ProtoMessage()    {}
func (*CpuOndemandInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{7}
}
func (m *CpuOndemandInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuOndemandInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuOndemandInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuOndemandInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuOndemandInfo.Merge(m, src)
}
func (m *CpuOndemandInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuOndemandInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuOndemandInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuOndemandInfo proto.InternalMessageInfo

func (m *CpuOndemandInfo) GetCpuUtilization() float64 {
	if m != nil {
		return m.CpuUtilization
	}
	return 0
}

func (m *CpuOndemandInfo) GetCpuSystem() float64 {
	if m != nil {
		return m.CpuSystem
	}
	return 0
}

func (m *CpuOndemandInfo) GetCpuIdle() float64 {
	if m != nil {
		return m.CpuIdle
	}
	return 0
}

func (m *CpuOndemandInfo) GetCpuIowait() float64 {
	if m != nil {
		return m.CpuIowait
	}
	return 0
}

func (m *CpuOndemandInfo) GetCpuHintr() float64 {
	if m != nil {
		return m.CpuHintr
	}
	return 0
}

func (m *CpuOndemandInfo) GetCpuSintr() float64 {
	if m != nil {
		return m.CpuSintr
	}
	return 0
}

//////////////////////////////////
// VM 온디멘드 모니터링 메시지 정의 (CPUFREQ 메트릭)
//////////////////////////////////
type CpuFreqOndemandInfoResponse struct {
	Name                 string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags      `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Time                 string     `protobuf:"bytes,3,opt,name=time,proto3" json:"time" yaml:"time"`
	Values               []*CpuInfo `protobuf:"bytes,4,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CpuFreqOndemandInfoResponse) Reset()         { *m = CpuFreqOndemandInfoResponse{} }
func (m *CpuFreqOndemandInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CpuFreqOndemandInfoResponse) ProtoMessage()    {}
func (*CpuFreqOndemandInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{8}
}
func (m *CpuFreqOndemandInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuFreqOndemandInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuFreqOndemandInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuFreqOndemandInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuFreqOndemandInfoResponse.Merge(m, src)
}
func (m *CpuFreqOndemandInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CpuFreqOndemandInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuFreqOndemandInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpuFreqOndemandInfoResponse proto.InternalMessageInfo

func (m *CpuFreqOndemandInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CpuFreqOndemandInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *CpuFreqOndemandInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *CpuFreqOndemandInfoResponse) GetValues() []*CpuInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type CpuFreqOndemandInfo struct {
	CpuSpeed             float64  `protobuf:"fixed64,1,opt,name=cpu_speed,proto3" json:"cpu_speed" yaml:"cpu_speed"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuFreqOndemandInfo) Reset()         { *m = CpuFreqOndemandInfo{} }
func (m *CpuFreqOndemandInfo) String() string { return proto.CompactTextString(m) }
func (*CpuFreqOndemandInfo) ProtoMessage()    {}
func (*CpuFreqOndemandInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{9}
}
func (m *CpuFreqOndemandInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuFreqOndemandInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuFreqOndemandInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuFreqOndemandInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuFreqOndemandInfo.Merge(m, src)
}
func (m *CpuFreqOndemandInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuFreqOndemandInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuFreqOndemandInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuFreqOndemandInfo proto.InternalMessageInfo

func (m *CpuFreqOndemandInfo) GetCpuSpeed() float64 {
	if m != nil {
		return m.CpuSpeed
	}
	return 0
}

type CpuInfoResponse struct {
	Name                 string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags      `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Values               []*CpuInfo `protobuf:"bytes,3,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CpuInfoResponse) Reset()         { *m = CpuInfoResponse{} }
func (m *CpuInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CpuInfoResponse) ProtoMessage()    {}
func (*CpuInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{10}
}
func (m *CpuInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuInfoResponse.Merge(m, src)
}
func (m *CpuInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CpuInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpuInfoResponse proto.InternalMessageInfo

func (m *CpuInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CpuInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *CpuInfoResponse) GetValues() []*CpuInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type CpuInfo struct {
	CpuUtilization       float64  `protobuf:"fixed64,1,opt,name=cpu_utilization,proto3" json:"cpu_utilization" yaml:"cpu_utilization"`
	CpuSystem            float64  `protobuf:"fixed64,2,opt,name=cpu_system,proto3" json:"cpu_system" yaml:"cpu_system"`
	CpuIdle              float64  `protobuf:"fixed64,3,opt,name=cpu_idle,proto3" json:"cpu_idle" yaml:"cpu_idle"`
	CpuIowait            float64  `protobuf:"fixed64,4,opt,name=cpu_iowait,proto3" json:"cpu_iowait" yaml:"cpu_iowait"`
	CpuHintr             float64  `protobuf:"fixed64,5,opt,name=cpu_hintr,proto3" json:"cpu_hintr" yaml:"cpu_hintr"`
	CpuSintr             float64  `protobuf:"fixed64,6,opt,name=cpu_sintr,proto3" json:"cpu_sintr" yaml:"cpu_sintr"`
	CpuUser              float64  `protobuf:"fixed64,7,opt,name=cpu_user,proto3" json:"cpu_user" yaml:"cpu_user"`
	CpuNice              float64  `protobuf:"fixed64,8,opt,name=cpu_nice,proto3" json:"cpu_nice" yaml:"cpu_nice"`
	CpuSteal             float64  `protobuf:"fixed64,9,opt,name=cpu_steal,proto3" json:"cpu_steal" yaml:"cpu_steal"`
	CpuGuest             float64  `protobuf:"fixed64,10,opt,name=cpu_guest,proto3" json:"cpu_guest" yaml:"cpu_guest"`
	CpuGuestNice         float64  `protobuf:"fixed64,11,opt,name=cpu_guest_nice,proto3" json:"cpu_guest_nice" yaml:"cpu_guest_nice"`
	Time                 string   `protobuf:"bytes,12,opt,name=time,proto3" json:"time" yaml:"time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuInfo) Reset()         { *m = CpuInfo{} }
func (m *CpuInfo) String() string { return proto.CompactTextString(m) }
func (*CpuInfo) ProtoMessage()    {}
func (*CpuInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{11}
}
func (m *CpuInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuInfo.Merge(m, src)
}
func (m *CpuInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuInfo proto.InternalMessageInfo

func (m *CpuInfo) GetCpuUtilization() float64 {
	if m != nil {
		return m.CpuUtilization
	}
	return 0
}

func (m *CpuInfo) GetCpuSystem() float64 {
	if m != nil {
		return m.CpuSystem
	}
	return 0
}

func (m *CpuInfo) GetCpuIdle() float64 {
	if m != nil {
		return m.CpuIdle
	}
	return 0
}

func (m *CpuInfo) GetCpuIowait() float64 {
	if m != nil {
		return m.CpuIowait
	}
	return 0
}

func (m *CpuInfo) GetCpuHintr() float64 {
	if m != nil {
		return m.CpuHintr
	}
	return 0
}

func (m *CpuInfo) GetCpuSintr() float64 {
	if m != nil {
		return m.CpuSintr
	}
	return 0
}

func (m *CpuInfo) GetCpuUser() float64 {
	if m != nil {
		return m.CpuUser
	}
	return 0
}

func (m *CpuInfo) GetCpuNice() float64 {
	if m != nil {
		return m.CpuNice
	}
	return 0
}

func (m *CpuInfo) GetCpuSteal() float64 {
	if m != nil {
		return m.CpuSteal
	}
	return 0
}

func (m *CpuInfo) GetCpuGuest() float64 {
	if m != nil {
		return m.CpuGuest
	}
	return 0
}

func (m *CpuInfo) GetCpuGuestNice() float64 {
	if m != nil {
		return m.CpuGuestNice
	}
	return 0
}

func (m *CpuInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type CpuFreqInfoResponse struct {
	Name                 string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags          `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Values               []*CpuFreqInfo `protobuf:"bytes,3,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CpuFreqInfoResponse) Reset()         { *m = CpuFreqInfoResponse{} }
func (m *CpuFreqInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CpuFreqInfoResponse) ProtoMessage()    {}
func (*CpuFreqInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{12}
}
func (m *CpuFreqInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuFreqInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuFreqInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuFreqInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuFreqInfoResponse.Merge(m, src)
}
func (m *CpuFreqInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CpuFreqInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuFreqInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpuFreqInfoResponse proto.InternalMessageInfo

func (m *CpuFreqInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CpuFreqInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *CpuFreqInfoResponse) GetValues() []*CpuFreqInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type CpuFreqInfo struct {
	CpuSpeed             float64  `protobuf:"fixed64,1,opt,name=cpu_speed,proto3" json:"cpu_speed" yaml:"cpu_speed"`
	Time                 string   `protobuf:"bytes,2,opt,name=time,proto3" json:"time" yaml:"time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuFreqInfo) Reset()         { *m = CpuFreqInfo{} }
func (m *CpuFreqInfo) String() string { return proto.CompactTextString(m) }
func (*CpuFreqInfo) ProtoMessage()    {}
func (*CpuFreqInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{13}
}
func (m *CpuFreqInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuFreqInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuFreqInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuFreqInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuFreqInfo.Merge(m, src)
}
func (m *CpuFreqInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuFreqInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuFreqInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuFreqInfo proto.InternalMessageInfo

func (m *CpuFreqInfo) GetCpuSpeed() float64 {
	if m != nil {
		return m.CpuSpeed
	}
	return 0
}

func (m *CpuFreqInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type MemoryInfoResponse struct {
	Name                 string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags         `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Values               []*MemoryInfo `protobuf:"bytes,3,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *MemoryInfoResponse) Reset()         { *m = MemoryInfoResponse{} }
func (m *MemoryInfoResponse) String() string { return proto.CompactTextString(m) }
func (*MemoryInfoResponse) ProtoMessage()    {}
func (*MemoryInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{14}
}
func (m *MemoryInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryInfoResponse.Merge(m, src)
}
func (m *MemoryInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *MemoryInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryInfoResponse proto.InternalMessageInfo

func (m *MemoryInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MemoryInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *MemoryInfoResponse) GetValues() []*MemoryInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type MemoryInfo struct {
	MemUtilization       float64  `protobuf:"fixed64,1,opt,name=mem_utilization,proto3" json:"mem_utilization" yaml:"mem_utilization"`
	MemTotal             float64  `protobuf:"fixed64,2,opt,name=mem_total,proto3" json:"mem_total" yaml:"mem_total"`
	MemUsed              float64  `protobuf:"fixed64,3,opt,name=mem_used,proto3" json:"mem_used" yaml:"mem_used"`
	MemFree              float64  `protobuf:"fixed64,4,opt,name=mem_free,proto3" json:"mem_free" yaml:"mem_free"`
	MemShared            float64  `protobuf:"fixed64,5,opt,name=mem_shared,proto3" json:"mem_shared" yaml:"mem_shared"`
	MemBuffers           float64  `protobuf:"fixed64,6,opt,name=mem_buffers,proto3" json:"mem_buffers" yaml:"mem_buffers"`
	MemCached            float64  `protobuf:"fixed64,7,opt,name=mem_cached,proto3" json:"mem_cached" yaml:"mem_cached"`
	Time                 string   `protobuf:"bytes,8,opt,name=time,proto3" json:"time" yaml:"time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemoryInfo) Reset()         { *m = MemoryInfo{} }
func (m *MemoryInfo) String() string { return proto.CompactTextString(m) }
func (*MemoryInfo) ProtoMessage()    {}
func (*MemoryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{15}
}
func (m *MemoryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryInfo.Merge(m, src)
}
func (m *MemoryInfo) XXX_Size() int {
	return m.Size()
}
func (m *MemoryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryInfo proto.InternalMessageInfo

func (m *MemoryInfo) GetMemUtilization() float64 {
	if m != nil {
		return m.MemUtilization
	}
	return 0
}

func (m *MemoryInfo) GetMemTotal() float64 {
	if m != nil {
		return m.MemTotal
	}
	return 0
}

func (m *MemoryInfo) GetMemUsed() float64 {
	if m != nil {
		return m.MemUsed
	}
	return 0
}

func (m *MemoryInfo) GetMemFree() float64 {
	if m != nil {
		return m.MemFree
	}
	return 0
}

func (m *MemoryInfo) GetMemShared() float64 {
	if m != nil {
		return m.MemShared
	}
	return 0
}

func (m *MemoryInfo) GetMemBuffers() float64 {
	if m != nil {
		return m.MemBuffers
	}
	return 0
}

func (m *MemoryInfo) GetMemCached() float64 {
	if m != nil {
		return m.MemCached
	}
	return 0
}

func (m *MemoryInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type DiskInfoResponse struct {
	Name                 string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags       `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Values               []*DiskInfo `protobuf:"bytes,3,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DiskInfoResponse) Reset()         { *m = DiskInfoResponse{} }
func (m *DiskInfoResponse) String() string { return proto.CompactTextString(m) }
func (*DiskInfoResponse) ProtoMessage()    {}
func (*DiskInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{16}
}
func (m *DiskInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskInfoResponse.Merge(m, src)
}
func (m *DiskInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *DiskInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiskInfoResponse proto.InternalMessageInfo

func (m *DiskInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DiskInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *DiskInfoResponse) GetValues() []*DiskInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type DiskInfo struct {
	Free                 float64  `protobuf:"fixed64,1,opt,name=free,proto3" json:"free" yaml:"free"`
	ReadBytes            float64  `protobuf:"fixed64,2,opt,name=read_bytes,proto3" json:"read_bytes" yaml:"read_bytes"`
	ReadTime             float64  `protobuf:"fixed64,3,opt,name=read_time,proto3" json:"read_time" yaml:"read_time"`
	Reads                float64  `protobuf:"fixed64,4,opt,name=reads,proto3" json:"reads" yaml:"reads"`
	Total                float64  `protobuf:"fixed64,5,opt,name=total,proto3" json:"total" yaml:"total"`
	Used                 float64  `protobuf:"fixed64,6,opt,name=used,proto3" json:"used" yaml:"used"`
	UsedPercent          float64  `protobuf:"fixed64,7,opt,name=used_percent,proto3" json:"used_percent" yaml:"used_percent"`
	WriteBytes           float64  `protobuf:"fixed64,8,opt,name=write_bytes,proto3" json:"write_bytes" yaml:"write_bytes"`
	WriteTime            float64  `protobuf:"fixed64,9,opt,name=write_time,proto3" json:"write_time" yaml:"write_time"`
	Writes               float64  `protobuf:"fixed64,10,opt,name=writes,proto3" json:"writes" yaml:"writes"`
	Time                 string   `protobuf:"bytes,11,opt,name=time,proto3" json:"time" yaml:"time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskInfo) Reset()         { *m = DiskInfo{} }
func (m *DiskInfo) String() string { return proto.CompactTextString(m) }
func (*DiskInfo) ProtoMessage()    {}
func (*DiskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{17}
}
func (m *DiskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskInfo.Merge(m, src)
}
func (m *DiskInfo) XXX_Size() int {
	return m.Size()
}
func (m *DiskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DiskInfo proto.InternalMessageInfo

func (m *DiskInfo) GetFree() float64 {
	if m != nil {
		return m.Free
	}
	return 0
}

func (m *DiskInfo) GetReadBytes() float64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *DiskInfo) GetReadTime() float64 {
	if m != nil {
		return m.ReadTime
	}
	return 0
}

func (m *DiskInfo) GetReads() float64 {
	if m != nil {
		return m.Reads
	}
	return 0
}

func (m *DiskInfo) GetTotal() float64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *DiskInfo) GetUsed() float64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *DiskInfo) GetUsedPercent() float64 {
	if m != nil {
		return m.UsedPercent
	}
	return 0
}

func (m *DiskInfo) GetWriteBytes() float64 {
	if m != nil {
		return m.WriteBytes
	}
	return 0
}

func (m *DiskInfo) GetWriteTime() float64 {
	if m != nil {
		return m.WriteTime
	}
	return 0
}

func (m *DiskInfo) GetWrites() float64 {
	if m != nil {
		return m.Writes
	}
	return 0
}

func (m *DiskInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type NetworkInfoResponse struct {
	Name                 string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Tags                 *Tags          `protobuf:"bytes,2,opt,name=tags,proto3" json:"tags" yaml:"tags"`
	Values               []*NetworkInfo `protobuf:"bytes,3,rep,name=values,proto3" json:"values" yaml:"values"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NetworkInfoResponse) Reset()         { *m = NetworkInfoResponse{} }
func (m *NetworkInfoResponse) String() string { return proto.CompactTextString(m) }
func (*NetworkInfoResponse) ProtoMessage()    {}
func (*NetworkInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{18}
}
func (m *NetworkInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInfoResponse.Merge(m, src)
}
func (m *NetworkInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInfoResponse proto.InternalMessageInfo

func (m *NetworkInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkInfoResponse) GetTags() *Tags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *NetworkInfoResponse) GetValues() []*NetworkInfo {
	if m != nil {
		return m.Values
	}
	return nil
}

type NetworkInfo struct {
	BytesIn              float64  `protobuf:"fixed64,1,opt,name=bytes_in,proto3" json:"bytes_in" yaml:"bytes_in"`
	BytesOut             float64  `protobuf:"fixed64,2,opt,name=bytes_out,proto3" json:"bytes_out" yaml:"bytes_out"`
	PktsIn               float64  `protobuf:"fixed64,3,opt,name=pkts_in,proto3" json:"pkts_in" yaml:"pkts_in"`
	PktsOut              float64  `protobuf:"fixed64,4,opt,name=pkts_out,proto3" json:"pkts_out" yaml:"pkts_out"`
	Time                 string   `protobuf:"bytes,5,opt,name=time,proto3" json:"time" yaml:"time"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkInfo) Reset()         { *m = NetworkInfo{} }
func (m *NetworkInfo) String() string { return proto.CompactTextString(m) }
func (*NetworkInfo) ProtoMessage()    {}
func (*NetworkInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{19}
}
func (m *NetworkInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInfo.Merge(m, src)
}
func (m *NetworkInfo) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInfo proto.InternalMessageInfo

func (m *NetworkInfo) GetBytesIn() float64 {
	if m != nil {
		return m.BytesIn
	}
	return 0
}

func (m *NetworkInfo) GetBytesOut() float64 {
	if m != nil {
		return m.BytesOut
	}
	return 0
}

func (m *NetworkInfo) GetPktsIn() float64 {
	if m != nil {
		return m.PktsIn
	}
	return 0
}

func (m *NetworkInfo) GetPktsOut() float64 {
	if m != nil {
		return m.PktsOut
	}
	return 0
}

func (m *NetworkInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

type CpuRtInfoResponse struct {
	MetricName           string     `protobuf:"bytes,1,opt,name=metric_name,json=metricName,proto3" json:"metricName" yaml:"metricName"`
	Time                 string     `protobuf:"bytes,2,opt,name=time,proto3" json:"time" yaml:"time"`
	Value                *CpuRtInfo `protobuf:"bytes,3,opt,name=value,proto3" json:"value" yaml:"value"`
	VmId                 string     `protobuf:"bytes,4,opt,name=vm_id,json=vmId,proto3" json:"vmId" yaml:"vmId"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CpuRtInfoResponse) Reset()         { *m = CpuRtInfoResponse{} }
func (m *CpuRtInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CpuRtInfoResponse) ProtoMessage()    {}
func (*CpuRtInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{20}
}
func (m *CpuRtInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuRtInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuRtInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuRtInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuRtInfoResponse.Merge(m, src)
}
func (m *CpuRtInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CpuRtInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuRtInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpuRtInfoResponse proto.InternalMessageInfo

func (m *CpuRtInfoResponse) GetMetricName() string {
	if m != nil {
		return m.MetricName
	}
	return ""
}

func (m *CpuRtInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *CpuRtInfoResponse) GetValue() *CpuRtInfo {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *CpuRtInfoResponse) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

type CpuRtInfo struct {
	CpuUtilization       float64  `protobuf:"fixed64,1,opt,name=cpu_utilization,proto3" json:"cpu_utilization" yaml:"cpu_utilization"`
	CpuSystem            float64  `protobuf:"fixed64,2,opt,name=cpu_system,proto3" json:"cpu_system" yaml:"cpu_system"`
	CpuIdle              float64  `protobuf:"fixed64,3,opt,name=cpu_idle,proto3" json:"cpu_idle" yaml:"cpu_idle"`
	CpuIowait            float64  `protobuf:"fixed64,4,opt,name=cpu_iowait,proto3" json:"cpu_iowait" yaml:"cpu_iowait"`
	CpuHintr             float64  `protobuf:"fixed64,5,opt,name=cpu_hintr,proto3" json:"cpu_hintr" yaml:"cpu_hintr"`
	CpuSintr             float64  `protobuf:"fixed64,6,opt,name=cpu_sintr,proto3" json:"cpu_sintr" yaml:"cpu_sintr"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuRtInfo) Reset()         { *m = CpuRtInfo{} }
func (m *CpuRtInfo) String() string { return proto.CompactTextString(m) }
func (*CpuRtInfo) ProtoMessage()    {}
func (*CpuRtInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{21}
}
func (m *CpuRtInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuRtInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuRtInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuRtInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuRtInfo.Merge(m, src)
}
func (m *CpuRtInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuRtInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuRtInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuRtInfo proto.InternalMessageInfo

func (m *CpuRtInfo) GetCpuUtilization() float64 {
	if m != nil {
		return m.CpuUtilization
	}
	return 0
}

func (m *CpuRtInfo) GetCpuSystem() float64 {
	if m != nil {
		return m.CpuSystem
	}
	return 0
}

func (m *CpuRtInfo) GetCpuIdle() float64 {
	if m != nil {
		return m.CpuIdle
	}
	return 0
}

func (m *CpuRtInfo) GetCpuIowait() float64 {
	if m != nil {
		return m.CpuIowait
	}
	return 0
}

func (m *CpuRtInfo) GetCpuHintr() float64 {
	if m != nil {
		return m.CpuHintr
	}
	return 0
}

func (m *CpuRtInfo) GetCpuSintr() float64 {
	if m != nil {
		return m.CpuSintr
	}
	return 0
}

type CpuFreqRtInfoResponse struct {
	MetricName           string         `protobuf:"bytes,1,opt,name=metric_name,json=metricName,proto3" json:"metricName" yaml:"metricName"`
	Time                 string         `protobuf:"bytes,2,opt,name=time,proto3" json:"time" yaml:"time"`
	Value                *CpuFreqRtInfo `protobuf:"bytes,3,opt,name=value,proto3" json:"value" yaml:"value"`
	VmId                 string         `protobuf:"bytes,4,opt,name=vm_id,json=vmId,proto3" json:"vmId" yaml:"vmId"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CpuFreqRtInfoResponse) Reset()         { *m = CpuFreqRtInfoResponse{} }
func (m *CpuFreqRtInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CpuFreqRtInfoResponse) ProtoMessage()    {}
func (*CpuFreqRtInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{22}
}
func (m *CpuFreqRtInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuFreqRtInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuFreqRtInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuFreqRtInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuFreqRtInfoResponse.Merge(m, src)
}
func (m *CpuFreqRtInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CpuFreqRtInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuFreqRtInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpuFreqRtInfoResponse proto.InternalMessageInfo

func (m *CpuFreqRtInfoResponse) GetMetricName() string {
	if m != nil {
		return m.MetricName
	}
	return ""
}

func (m *CpuFreqRtInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *CpuFreqRtInfoResponse) GetValue() *CpuFreqRtInfo {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *CpuFreqRtInfoResponse) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

type CpuFreqRtInfo struct {
	CpuSpeed             float64  `protobuf:"fixed64,1,opt,name=cpu_speed,proto3" json:"cpu_speed" yaml:"cpu_speed"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpuFreqRtInfo) Reset()         { *m = CpuFreqRtInfo{} }
func (m *CpuFreqRtInfo) String() string { return proto.CompactTextString(m) }
func (*CpuFreqRtInfo) ProtoMessage()    {}
func (*CpuFreqRtInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{23}
}
func (m *CpuFreqRtInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CpuFreqRtInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CpuFreqRtInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CpuFreqRtInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpuFreqRtInfo.Merge(m, src)
}
func (m *CpuFreqRtInfo) XXX_Size() int {
	return m.Size()
}
func (m *CpuFreqRtInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CpuFreqRtInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CpuFreqRtInfo proto.InternalMessageInfo

func (m *CpuFreqRtInfo) GetCpuSpeed() float64 {
	if m != nil {
		return m.CpuSpeed
	}
	return 0
}

type MemoryRtInfoResponse struct {
	MetricName           string        `protobuf:"bytes,1,opt,name=metric_name,json=metricName,proto3" json:"metricName" yaml:"metricName"`
	Time                 string        `protobuf:"bytes,2,opt,name=time,proto3" json:"time" yaml:"time"`
	Value                *MemoryRtInfo `protobuf:"bytes,3,opt,name=value,proto3" json:"value" yaml:"value"`
	VmId                 string        `protobuf:"bytes,4,opt,name=vm_id,json=vmId,proto3" json:"vmId" yaml:"vmId"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *MemoryRtInfoResponse) Reset()         { *m = MemoryRtInfoResponse{} }
func (m *MemoryRtInfoResponse) String() string { return proto.CompactTextString(m) }
func (*MemoryRtInfoResponse) ProtoMessage()    {}
func (*MemoryRtInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{24}
}
func (m *MemoryRtInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryRtInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryRtInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryRtInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryRtInfoResponse.Merge(m, src)
}
func (m *MemoryRtInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *MemoryRtInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryRtInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryRtInfoResponse proto.InternalMessageInfo

func (m *MemoryRtInfoResponse) GetMetricName() string {
	if m != nil {
		return m.MetricName
	}
	return ""
}

func (m *MemoryRtInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *MemoryRtInfoResponse) GetValue() *MemoryRtInfo {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *MemoryRtInfoResponse) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

type MemoryRtInfo struct {
	MemUtilization       float64  `protobuf:"fixed64,1,opt,name=mem_utilization,proto3" json:"mem_utilization" yaml:"mem_utilization"`
	MemTotal             float64  `protobuf:"fixed64,2,opt,name=mem_total,proto3" json:"mem_total" yaml:"mem_total"`
	MemUsed              float64  `protobuf:"fixed64,3,opt,name=mem_used,proto3" json:"mem_used" yaml:"mem_used"`
	MemFree              float64  `protobuf:"fixed64,4,opt,name=mem_free,proto3" json:"mem_free" yaml:"mem_free"`
	MemShared            float64  `protobuf:"fixed64,5,opt,name=mem_shared,proto3" json:"mem_shared" yaml:"mem_shared"`
	MemBuffers           float64  `protobuf:"fixed64,6,opt,name=mem_buffers,proto3" json:"mem_buffers" yaml:"mem_buffers"`
	MemCached            float64  `protobuf:"fixed64,7,opt,name=mem_cached,proto3" json:"mem_cached" yaml:"mem_cached"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MemoryRtInfo) Reset()         { *m = MemoryRtInfo{} }
func (m *MemoryRtInfo) String() string { return proto.CompactTextString(m) }
func (*MemoryRtInfo) ProtoMessage()    {}
func (*MemoryRtInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{25}
}
func (m *MemoryRtInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryRtInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryRtInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryRtInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryRtInfo.Merge(m, src)
}
func (m *MemoryRtInfo) XXX_Size() int {
	return m.Size()
}
func (m *MemoryRtInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryRtInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryRtInfo proto.InternalMessageInfo

func (m *MemoryRtInfo) GetMemUtilization() float64 {
	if m != nil {
		return m.MemUtilization
	}
	return 0
}

func (m *MemoryRtInfo) GetMemTotal() float64 {
	if m != nil {
		return m.MemTotal
	}
	return 0
}

func (m *MemoryRtInfo) GetMemUsed() float64 {
	if m != nil {
		return m.MemUsed
	}
	return 0
}

func (m *MemoryRtInfo) GetMemFree() float64 {
	if m != nil {
		return m.MemFree
	}
	return 0
}

func (m *MemoryRtInfo) GetMemShared() float64 {
	if m != nil {
		return m.MemShared
	}
	return 0
}

func (m *MemoryRtInfo) GetMemBuffers() float64 {
	if m != nil {
		return m.MemBuffers
	}
	return 0
}

func (m *MemoryRtInfo) GetMemCached() float64 {
	if m != nil {
		return m.MemCached
	}
	return 0
}

type DiskRtInfoResponse struct {
	MetricName           string      `protobuf:"bytes,1,opt,name=metric_name,json=metricName,proto3" json:"metricName" yaml:"metricName"`
	Time                 string      `protobuf:"bytes,2,opt,name=time,proto3" json:"time" yaml:"time"`
	Value                *DiskRtInfo `protobuf:"bytes,3,opt,name=value,proto3" json:"value" yaml:"value"`
	VmId                 string      `protobuf:"bytes,4,opt,name=vm_id,json=vmId,proto3" json:"vmId" yaml:"vmId"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DiskRtInfoResponse) Reset()         { *m = DiskRtInfoResponse{} }
func (m *DiskRtInfoResponse) String() string { return proto.CompactTextString(m) }
func (*DiskRtInfoResponse) ProtoMessage()    {}
func (*DiskRtInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{26}
}
func (m *DiskRtInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskRtInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskRtInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskRtInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskRtInfoResponse.Merge(m, src)
}
func (m *DiskRtInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *DiskRtInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskRtInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiskRtInfoResponse proto.InternalMessageInfo

func (m *DiskRtInfoResponse) GetMetricName() string {
	if m != nil {
		return m.MetricName
	}
	return ""
}

func (m *DiskRtInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *DiskRtInfoResponse) GetValue() *DiskRtInfo {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *DiskRtInfoResponse) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

type DiskRtInfo struct {
	DiskFree             float64  `protobuf:"fixed64,1,opt,name=disk_free,proto3" json:"disk_free" yaml:"disk_free"`
	DiskTotal            float64  `protobuf:"fixed64,2,opt,name=disk_total,proto3" json:"disk_total" yaml:"disk_total"`
	DiskUsed             float64  `protobuf:"fixed64,3,opt,name=disk_used,proto3" json:"disk_used" yaml:"disk_used"`
	DiskUtilization      float64  `protobuf:"fixed64,4,opt,name=disk_utilization,proto3" json:"disk_utilization" yaml:"disk_utilization"`
	KbRead               float64  `protobuf:"fixed64,5,opt,name=kb_read,proto3" json:"kb_read" yaml:"kb_read"`
	KbWritten            float64  `protobuf:"fixed64,6,opt,name=kb_written,proto3" json:"kb_written" yaml:"kb_written"`
	OpsRead              float64  `protobuf:"fixed64,7,opt,name=ops_read,proto3" json:"ops_read" yaml:"ops_read"`
	OpsWrite             float64  `protobuf:"fixed64,8,opt,name=ops_write,proto3" json:"ops_write" yaml:"ops_write"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskRtInfo) Reset()         { *m = DiskRtInfo{} }
func (m *DiskRtInfo) String() string { return proto.CompactTextString(m) }
func (*DiskRtInfo) ProtoMessage()    {}
func (*DiskRtInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{27}
}
func (m *DiskRtInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskRtInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskRtInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskRtInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskRtInfo.Merge(m, src)
}
func (m *DiskRtInfo) XXX_Size() int {
	return m.Size()
}
func (m *DiskRtInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskRtInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DiskRtInfo proto.InternalMessageInfo

func (m *DiskRtInfo) GetDiskFree() float64 {
	if m != nil {
		return m.DiskFree
	}
	return 0
}

func (m *DiskRtInfo) GetDiskTotal() float64 {
	if m != nil {
		return m.DiskTotal
	}
	return 0
}

func (m *DiskRtInfo) GetDiskUsed() float64 {
	if m != nil {
		return m.DiskUsed
	}
	return 0
}

func (m *DiskRtInfo) GetDiskUtilization() float64 {
	if m != nil {
		return m.DiskUtilization
	}
	return 0
}

func (m *DiskRtInfo) GetKbRead() float64 {
	if m != nil {
		return m.KbRead
	}
	return 0
}

func (m *DiskRtInfo) GetKbWritten() float64 {
	if m != nil {
		return m.KbWritten
	}
	return 0
}

func (m *DiskRtInfo) GetOpsRead() float64 {
	if m != nil {
		return m.OpsRead
	}
	return 0
}

func (m *DiskRtInfo) GetOpsWrite() float64 {
	if m != nil {
		return m.OpsWrite
	}
	return 0
}

type NetworkRtInfoResponse struct {
	MetricName           string         `protobuf:"bytes,1,opt,name=metric_name,json=metricName,proto3" json:"metricName" yaml:"metricName"`
	Time                 string         `protobuf:"bytes,2,opt,name=time,proto3" json:"time" yaml:"time"`
	Value                *NetworkRtInfo `protobuf:"bytes,3,opt,name=value,proto3" json:"value" yaml:"value"`
	VmId                 string         `protobuf:"bytes,4,opt,name=vm_id,json=vmId,proto3" json:"vmId" yaml:"vmId"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NetworkRtInfoResponse) Reset()         { *m = NetworkRtInfoResponse{} }
func (m *NetworkRtInfoResponse) String() string { return proto.CompactTextString(m) }
func (*NetworkRtInfoResponse) ProtoMessage()    {}
func (*NetworkRtInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{28}
}
func (m *NetworkRtInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkRtInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkRtInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkRtInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkRtInfoResponse.Merge(m, src)
}
func (m *NetworkRtInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *NetworkRtInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkRtInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkRtInfoResponse proto.InternalMessageInfo

func (m *NetworkRtInfoResponse) GetMetricName() string {
	if m != nil {
		return m.MetricName
	}
	return ""
}

func (m *NetworkRtInfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *NetworkRtInfoResponse) GetValue() *NetworkRtInfo {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *NetworkRtInfoResponse) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

type NetworkRtInfo struct {
	BytesIn              float64  `protobuf:"fixed64,1,opt,name=bytes_in,proto3" json:"bytes_in" yaml:"bytes_in"`
	BytesOut             float64  `protobuf:"fixed64,2,opt,name=bytes_out,proto3" json:"bytes_out" yaml:"bytes_out"`
	PktsIn               float64  `protobuf:"fixed64,3,opt,name=pkts_in,proto3" json:"pkts_in" yaml:"pkts_in"`
	PktsOut              float64  `protobuf:"fixed64,4,opt,name=pkts_out,proto3" json:"pkts_out" yaml:"pkts_out"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkRtInfo) Reset()         { *m = NetworkRtInfo{} }
func (m *NetworkRtInfo) String() string { return proto.CompactTextString(m) }
func (*NetworkRtInfo) ProtoMessage()    {}
func (*NetworkRtInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{29}
}
func (m *NetworkRtInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkRtInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkRtInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkRtInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkRtInfo.Merge(m, src)
}
func (m *NetworkRtInfo) XXX_Size() int {
	return m.Size()
}
func (m *NetworkRtInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkRtInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkRtInfo proto.InternalMessageInfo

func (m *NetworkRtInfo) GetBytesIn() float64 {
	if m != nil {
		return m.BytesIn
	}
	return 0
}

func (m *NetworkRtInfo) GetBytesOut() float64 {
	if m != nil {
		return m.BytesOut
	}
	return 0
}

func (m *NetworkRtInfo) GetPktsIn() float64 {
	if m != nil {
		return m.PktsIn
	}
	return 0
}

func (m *NetworkRtInfo) GetPktsOut() float64 {
	if m != nil {
		return m.PktsOut
	}
	return 0
}

type MonitoringConfigRequest struct {
	Item                 *MonitoringConfigInfo `protobuf:"bytes,1,opt,name=item,json=common,proto3" json:"common" yaml:"common"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MonitoringConfigRequest) Reset()         { *m = MonitoringConfigRequest{} }
func (m *MonitoringConfigRequest) String() string { return proto.CompactTextString(m) }
func (*MonitoringConfigRequest) ProtoMessage()    {}
func (*MonitoringConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{30}
}
func (m *MonitoringConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonitoringConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonitoringConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonitoringConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonitoringConfigRequest.Merge(m, src)
}
func (m *MonitoringConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *MonitoringConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MonitoringConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MonitoringConfigRequest proto.InternalMessageInfo

func (m *MonitoringConfigRequest) GetItem() *MonitoringConfigInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

type MonitoringConfigResponse struct {
	Item                 *MonitoringConfigInfo `protobuf:"bytes,1,opt,name=item,json=common,proto3" json:"common" yaml:"common"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *MonitoringConfigResponse) Reset()         { *m = MonitoringConfigResponse{} }
func (m *MonitoringConfigResponse) String() string { return proto.CompactTextString(m) }
func (*MonitoringConfigResponse) ProtoMessage()    {}
func (*MonitoringConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{31}
}
func (m *MonitoringConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonitoringConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonitoringConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonitoringConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonitoringConfigResponse.Merge(m, src)
}
func (m *MonitoringConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *MonitoringConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MonitoringConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MonitoringConfigResponse proto.InternalMessageInfo

func (m *MonitoringConfigResponse) GetItem() *MonitoringConfigInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

type MonitoringConfigInfo struct {
	AgentInterval        int32    `protobuf:"varint,1,opt,name=agent_interval,proto3" json:"agent_interval" yaml:"agent_interval"`
	CollectorInterval    int32    `protobuf:"varint,2,opt,name=collector_interval,proto3" json:"collector_interval" yaml:"collector_interval"`
	ScheduleInterval     int32    `protobuf:"varint,3,opt,name=schedule_interval,proto3" json:"schedule_interval" yaml:"schedule_interval"`
	MaxHostCount         int32    `protobuf:"varint,4,opt,name=max_host_count,proto3" json:"max_host_count" yaml:"max_host_count"`
	AgentTtl             int32    `protobuf:"varint,5,opt,name=agent_ttl,json=agent_TTL,proto3" json:"agent_TTL" yaml:"agent_TTL"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MonitoringConfigInfo) Reset()         { *m = MonitoringConfigInfo{} }
func (m *MonitoringConfigInfo) String() string { return proto.CompactTextString(m) }
func (*MonitoringConfigInfo) ProtoMessage()    {}
func (*MonitoringConfigInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{32}
}
func (m *MonitoringConfigInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonitoringConfigInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonitoringConfigInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonitoringConfigInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonitoringConfigInfo.Merge(m, src)
}
func (m *MonitoringConfigInfo) XXX_Size() int {
	return m.Size()
}
func (m *MonitoringConfigInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MonitoringConfigInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MonitoringConfigInfo proto.InternalMessageInfo

func (m *MonitoringConfigInfo) GetAgentInterval() int32 {
	if m != nil {
		return m.AgentInterval
	}
	return 0
}

func (m *MonitoringConfigInfo) GetCollectorInterval() int32 {
	if m != nil {
		return m.CollectorInterval
	}
	return 0
}

func (m *MonitoringConfigInfo) GetScheduleInterval() int32 {
	if m != nil {
		return m.ScheduleInterval
	}
	return 0
}

func (m *MonitoringConfigInfo) GetMaxHostCount() int32 {
	if m != nil {
		return m.MaxHostCount
	}
	return 0
}

func (m *MonitoringConfigInfo) GetAgentTtl() int32 {
	if m != nil {
		return m.AgentTtl
	}
	return 0
}

type InstallTelegrafRequest struct {
	NsId                 string   `protobuf:"bytes,1,opt,name=ns_id,proto3" json:"ns_id" yaml:"ns_id"`
	McisId               string   `protobuf:"bytes,2,opt,name=mcis_id,proto3" json:"mcis_id" yaml:"mcis_id"`
	VmId                 string   `protobuf:"bytes,3,opt,name=vm_id,proto3" json:"vm_id" yaml:"vm_id"`
	PublicIp             string   `protobuf:"bytes,4,opt,name=public_ip,proto3" json:"public_ip" yaml:"public_ip"`
	UserName             string   `protobuf:"bytes,5,opt,name=user_name,proto3" json:"user_name" yaml:"user_name"`
	SshKey               string   `protobuf:"bytes,6,opt,name=ssh_key,proto3" json:"ssh_key" yaml:"ssh_key"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InstallTelegrafRequest) Reset()         { *m = InstallTelegrafRequest{} }
func (m *InstallTelegrafRequest) String() string { return proto.CompactTextString(m) }
func (*InstallTelegrafRequest) ProtoMessage()    {}
func (*InstallTelegrafRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3ada617ac924eafc, []int{33}
}
func (m *InstallTelegrafRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallTelegrafRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallTelegrafRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallTelegrafRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallTelegrafRequest.Merge(m, src)
}
func (m *InstallTelegrafRequest) XXX_Size() int {
	return m.Size()
}
func (m *InstallTelegrafRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallTelegrafRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InstallTelegrafRequest proto.InternalMessageInfo

func (m *InstallTelegrafRequest) GetNsId() string {
	if m != nil {
		return m.NsId
	}
	return ""
}

func (m *InstallTelegrafRequest) GetMcisId() string {
	if m != nil {
		return m.McisId
	}
	return ""
}

func (m *InstallTelegrafRequest) GetVmId() string {
	if m != nil {
		return m.VmId
	}
	return ""
}

func (m *InstallTelegrafRequest) GetPublicIp() string {
	if m != nil {
		return m.PublicIp
	}
	return ""
}

func (m *InstallTelegrafRequest) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *InstallTelegrafRequest) GetSshKey() string {
	if m != nil {
		return m.SshKey
	}
	return ""
}

func init() {
	proto.RegisterType((*Empty)(nil), "cbdragonfly.Empty")
	proto.RegisterType((*MessageResponse)(nil), "cbdragonfly.MessageResponse")
	proto.RegisterType((*Tags)(nil), "cbdragonfly.Tags")
	proto.RegisterType((*VMMonQryRequest)(nil), "cbdragonfly.VMMonQryRequest")
	proto.RegisterType((*VMOndemandMonQryRequest)(nil), "cbdragonfly.VMOndemandMonQryRequest")
	proto.RegisterType((*VMLatestMonQryRequest)(nil), "cbdragonfly.VMLatestMonQryRequest")
	proto.RegisterType((*CpuOndemandInfoResponse)(nil), "cbdragonfly.CpuOndemandInfoResponse")
	proto.RegisterType((*CpuOndemandInfo)(nil), "cbdragonfly.CpuOndemandInfo")
	proto.RegisterType((*CpuFreqOndemandInfoResponse)(nil), "cbdragonfly.CpuFreqOndemandInfoResponse")
	proto.RegisterType((*CpuFreqOndemandInfo)(nil), "cbdragonfly.CpuFreqOndemandInfo")
	proto.RegisterType((*CpuInfoResponse)(nil), "cbdragonfly.CpuInfoResponse")
	proto.RegisterType((*CpuInfo)(nil), "cbdragonfly.CpuInfo")
	proto.RegisterType((*CpuFreqInfoResponse)(nil), "cbdragonfly.CpuFreqInfoResponse")
	proto.RegisterType((*CpuFreqInfo)(nil), "cbdragonfly.CpuFreqInfo")
	proto.RegisterType((*MemoryInfoResponse)(nil), "cbdragonfly.MemoryInfoResponse")
	proto.RegisterType((*MemoryInfo)(nil), "cbdragonfly.MemoryInfo")
	proto.RegisterType((*DiskInfoResponse)(nil), "cbdragonfly.DiskInfoResponse")
	proto.RegisterType((*DiskInfo)(nil), "cbdragonfly.DiskInfo")
	proto.RegisterType((*NetworkInfoResponse)(nil), "cbdragonfly.NetworkInfoResponse")
	proto.RegisterType((*NetworkInfo)(nil), "cbdragonfly.NetworkInfo")
	proto.RegisterType((*CpuRtInfoResponse)(nil), "cbdragonfly.CpuRtInfoResponse")
	proto.RegisterType((*CpuRtInfo)(nil), "cbdragonfly.CpuRtInfo")
	proto.RegisterType((*CpuFreqRtInfoResponse)(nil), "cbdragonfly.CpuFreqRtInfoResponse")
	proto.RegisterType((*CpuFreqRtInfo)(nil), "cbdragonfly.CpuFreqRtInfo")
	proto.RegisterType((*MemoryRtInfoResponse)(nil), "cbdragonfly.MemoryRtInfoResponse")
	proto.RegisterType((*MemoryRtInfo)(nil), "cbdragonfly.MemoryRtInfo")
	proto.RegisterType((*DiskRtInfoResponse)(nil), "cbdragonfly.DiskRtInfoResponse")
	proto.RegisterType((*DiskRtInfo)(nil), "cbdragonfly.DiskRtInfo")
	proto.RegisterType((*NetworkRtInfoResponse)(nil), "cbdragonfly.NetworkRtInfoResponse")
	proto.RegisterType((*NetworkRtInfo)(nil), "cbdragonfly.NetworkRtInfo")
	proto.RegisterType((*MonitoringConfigRequest)(nil), "cbdragonfly.MonitoringConfigRequest")
	proto.RegisterType((*MonitoringConfigResponse)(nil), "cbdragonfly.MonitoringConfigResponse")
	proto.RegisterType((*MonitoringConfigInfo)(nil), "cbdragonfly.MonitoringConfigInfo")
	proto.RegisterType((*InstallTelegrafRequest)(nil), "cbdragonfly.InstallTelegrafRequest")
}

func init() { proto.RegisterFile("cbdragonfly/cbdragonfly.proto", fileDescriptor_3ada617ac924eafc) }

var fileDescriptor_3ada617ac924eafc = []byte{
	// 2334 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x5b, 0x8f, 0x1b, 0x49,
	0xf5, 0x8f, 0x6f, 0x73, 0x29, 0x4f, 0x32, 0x93, 0x4e, 0x26, 0xe3, 0x4c, 0x92, 0xe9, 0xa4, 0x76,
	0x57, 0xff, 0x48, 0xfb, 0x67, 0x23, 0x12, 0xa4, 0x95, 0x58, 0x89, 0x95, 0x32, 0x81, 0x90, 0x8b,
	0x13, 0x52, 0x19, 0x66, 0x1f, 0x10, 0xb2, 0x7a, 0xec, 0x1a, 0x4f, 0x6b, 0xdc, 0xdd, 0xde, 0xee,
	0x76, 0x82, 0xe1, 0x8d, 0x15, 0x48, 0x7c, 0x00, 0xa4, 0x3c, 0xf2, 0x8a, 0x04, 0xbc, 0xf0, 0x21,
	0x00, 0xf1, 0xc0, 0xe5, 0x03, 0xb4, 0x50, 0x78, 0xf3, 0x03, 0x12, 0x96, 0x78, 0x44, 0xa0, 0x53,
	0xb7, 0x53, 0xdd, 0xb6, 0x07, 0x47, 0x49, 0x34, 0x89, 0x36, 0x4f, 0xae, 0xfa, 0x9d, 0x3a, 0x97,
	0x3e, 0x75, 0xce, 0xa9, 0x8b, 0x8b, 0x5c, 0x6a, 0xef, 0x75, 0x62, 0xaf, 0x1b, 0x85, 0xfb, 0xbd,
	0xe1, 0x35, 0xab, 0xfd, 0x51, 0x3f, 0x8e, 0xd2, 0xc8, 0xa9, 0x5b, 0xd0, 0xe6, 0xd9, 0x6e, 0xd4,
	0x8d, 0x04, 0x7e, 0x0d, 0x5a, 0x72, 0x08, 0x5d, 0x24, 0xb5, 0x6f, 0x06, 0xfd, 0x74, 0x48, 0xef,
	0x92, 0xd5, 0x26, 0x4f, 0x12, 0xaf, 0xcb, 0x19, 0x4f, 0xfa, 0x51, 0x98, 0x70, 0xe7, 0x63, 0xb2,
	0x18, 0x48, 0xa8, 0x51, 0xba, 0x5c, 0xba, 0xba, 0x7c, 0xf3, 0xd2, 0x28, 0x73, 0x35, 0x34, 0xce,
	0xdc, 0x53, 0x43, 0x2f, 0xe8, 0x7d, 0x9d, 0x2a, 0x80, 0x32, 0x4d, 0xa2, 0xcf, 0x4a, 0xa4, 0xba,
	0xe3, 0x75, 0x13, 0xe7, 0xff, 0x49, 0x2d, 0x4c, 0x5a, 0x7e, 0x47, 0xf1, 0x6f, 0x8c, 0x32, 0xb7,
	0x1a, 0x26, 0x77, 0x3a, 0xe3, 0xcc, 0xad, 0x4b, 0x66, 0xe8, 0x51, 0x26, 0x40, 0xe7, 0x6b, 0x64,
	0x31, 0x68, 0xfb, 0x62, 0x7c, 0x59, 0x8c, 0xbf, 0x30, 0xca, 0xdc, 0x05, 0x80, 0x04, 0xc7, 0x49,
	0xa5, 0x4e, 0xf4, 0x29, 0x53, 0x04, 0xd0, 0xf1, 0x24, 0x00, 0x9e, 0x0a, 0xea, 0x78, 0x12, 0xd8,
	0x3a, 0xa0, 0x47, 0x99, 0x00, 0xe9, 0xcf, 0x2b, 0x64, 0x75, 0xb7, 0xd9, 0x8c, 0xc2, 0x47, 0xf1,
	0x90, 0xf1, 0xcf, 0x07, 0x3c, 0x49, 0x9d, 0x6b, 0x79, 0x2b, 0xcf, 0x8f, 0x32, 0x57, 0x02, 0xe3,
	0xcc, 0x5d, 0xd1, 0x66, 0xb6, 0xfc, 0x0e, 0x65, 0x12, 0x16, 0x8e, 0xc9, 0x19, 0x2a, 0x1d, 0x23,
	0x21, 0xcb, 0x31, 0x12, 0x00, 0xc7, 0xc8, 0x16, 0x68, 0xb2, 0x6d, 0x15, 0x9a, 0x04, 0x80, 0x9a,
	0x44, 0x97, 0x32, 0x09, 0x3b, 0xb7, 0x48, 0xbd, 0xcf, 0x63, 0x3f, 0xea, 0xb4, 0xd2, 0x61, 0x9f,
	0x37, 0xaa, 0x82, 0xed, 0xbd, 0x51, 0xe6, 0x12, 0x09, 0xef, 0x0c, 0xfb, 0x30, 0x13, 0xa7, 0x25,
	0x2f, 0x62, 0x94, 0x59, 0x03, 0x9c, 0x0e, 0x39, 0x93, 0xa4, 0x5e, 0xea, 0x27, 0xa9, 0xdf, 0x4e,
	0x5a, 0xed, 0xd8, 0x4f, 0x79, 0xec, 0x7b, 0x8d, 0x9a, 0x90, 0x76, 0x63, 0x94, 0xb9, 0x0e, 0x92,
	0xb7, 0x15, 0x75, 0x9c, 0xb9, 0xe7, 0xa5, 0xd4, 0x49, 0x1a, 0x65, 0x53, 0x18, 0x9c, 0x4f, 0xc8,
	0x52, 0x67, 0x10, 0x7b, 0xa9, 0x1f, 0x85, 0x8d, 0x05, 0x21, 0xda, 0x1d, 0x65, 0xae, 0xc1, 0xc6,
	0x99, 0xbb, 0x2a, 0x05, 0x6a, 0x84, 0x32, 0x43, 0xa4, 0xff, 0x2c, 0x91, 0x8d, 0xdd, 0xe6, 0xc3,
	0xb0, 0xc3, 0x03, 0x2f, 0xec, 0xbc, 0x35, 0xf3, 0xf3, 0x09, 0x59, 0xf2, 0xba, 0x3c, 0x4c, 0x5b,
	0x7e, 0x5f, 0x4d, 0x8e, 0xf8, 0x66, 0x8d, 0xe1, 0x37, 0x6b, 0x84, 0x32, 0x43, 0xa4, 0xcf, 0xca,
	0x64, 0x7d, 0xb7, 0x79, 0xdf, 0x4b, 0x79, 0x92, 0xbe, 0x35, 0x5f, 0x3c, 0x23, 0x96, 0xaa, 0xaf,
	0x34, 0x96, 0xe8, 0x4f, 0xcb, 0x64, 0x63, 0xbb, 0x3f, 0xd0, 0xf1, 0x70, 0x27, 0xdc, 0x8f, 0x4c,
	0x59, 0xfa, 0x90, 0x54, 0x43, 0x2f, 0xe0, 0xb9, 0x9a, 0xe2, 0x05, 0xdc, 0xaa, 0x29, 0x5e, 0xc0,
	0xa1, 0xa6, 0x78, 0x01, 0x77, 0xbe, 0x41, 0xaa, 0xa9, 0xd7, 0x4d, 0x84, 0x57, 0xea, 0xd7, 0x4f,
	0x7f, 0x64, 0x17, 0x49, 0x28, 0x51, 0x92, 0x1f, 0x86, 0x20, 0x3f, 0xf4, 0x28, 0x13, 0x20, 0x28,
	0x4b, 0xfd, 0x80, 0xdb, 0xc5, 0x05, 0xfa, 0xd6, 0x60, 0x5f, 0x28, 0x83, 0x1f, 0xe7, 0x11, 0x59,
	0x78, 0xe2, 0xf5, 0x06, 0x3c, 0x69, 0x54, 0x2f, 0x57, 0xae, 0xd6, 0xaf, 0x5f, 0xcc, 0xa9, 0x2b,
	0x7c, 0x8f, 0xac, 0x6e, 0x72, 0x3c, 0x56, 0x37, 0xd9, 0xa7, 0x4c, 0x11, 0xe8, 0x6f, 0x2b, 0x64,
	0xb5, 0xc0, 0xe8, 0x7c, 0x46, 0x56, 0xdb, 0xfd, 0x41, 0x6b, 0x90, 0xfa, 0x3d, 0xff, 0x87, 0x32,
	0xdf, 0xc0, 0x17, 0xa5, 0x9b, 0x5f, 0x19, 0x65, 0x6e, 0x91, 0x34, 0xce, 0xdc, 0x73, 0x52, 0x74,
	0x81, 0x40, 0x59, 0x71, 0xa8, 0xb3, 0x4d, 0x08, 0x40, 0xc9, 0x30, 0x49, 0x79, 0x20, 0x5c, 0x56,
	0x92, 0xc5, 0x06, 0x51, 0x2c, 0x36, 0x88, 0x51, 0x66, 0x0d, 0x80, 0x94, 0x80, 0x9e, 0xdf, 0xe9,
	0x49, 0xaf, 0x95, 0x64, 0x4a, 0x68, 0x0c, 0x53, 0x42, 0x23, 0x94, 0x19, 0xa2, 0xb6, 0xc0, 0x8f,
	0x9e, 0x7a, 0x7e, 0x2a, 0x82, 0xca, 0xb2, 0x40, 0xa2, 0x79, 0x0b, 0x24, 0xa6, 0x2c, 0x90, 0x1d,
	0xe7, 0x53, 0xb2, 0x0c, 0xbd, 0x03, 0x3f, 0x4c, 0x63, 0x51, 0xe4, 0x4a, 0x37, 0xaf, 0x8c, 0x32,
	0x17, 0xc1, 0x71, 0xe6, 0xae, 0xa1, 0x08, 0x01, 0x51, 0x86, 0x64, 0x2d, 0x20, 0x11, 0x02, 0x16,
	0xf2, 0x02, 0x92, 0x49, 0x01, 0x89, 0x25, 0x40, 0xb6, 0x7f, 0x5c, 0x26, 0x17, 0xb6, 0xfb, 0x83,
	0x6f, 0xc5, 0xfc, 0xf3, 0xb7, 0x2c, 0x84, 0xef, 0x14, 0x42, 0xf8, 0x6c, 0x31, 0x84, 0xe7, 0x0f,
	0xdd, 0x5d, 0x72, 0x66, 0x8a, 0x0f, 0x8c, 0x73, 0xfb, 0x9c, 0x77, 0x54, 0xdc, 0xa2, 0x73, 0x01,
	0x2c, 0x38, 0x17, 0x20, 0xed, 0x5c, 0xd1, 0xfe, 0x43, 0x49, 0xa4, 0xc4, 0xf1, 0x39, 0x14, 0x7d,
	0x54, 0x79, 0x59, 0x1f, 0xfd, 0x72, 0x81, 0x2c, 0x2a, 0x86, 0x77, 0x69, 0xfd, 0xa6, 0xa7, 0xb5,
	0xf6, 0xc1, 0x20, 0xe1, 0x71, 0x63, 0x31, 0xef, 0x03, 0xc0, 0xf2, 0x3e, 0x00, 0x44, 0xf9, 0x00,
	0x9a, 0x9a, 0x39, 0xf4, 0xdb, 0xbc, 0xb1, 0x94, 0x67, 0x06, 0x2c, 0xcf, 0x0c, 0x88, 0x62, 0x86,
	0xa6, 0x31, 0x3d, 0xe5, 0x5e, 0xaf, 0xb1, 0x5c, 0x30, 0x1d, 0xc0, 0x82, 0xe9, 0x00, 0x69, 0xd3,
	0xa1, 0xad, 0x05, 0x74, 0x61, 0x7b, 0xd1, 0x20, 0x79, 0x01, 0x02, 0xcc, 0x0b, 0x10, 0x90, 0x12,
	0x20, 0xda, 0xce, 0x63, 0x72, 0xca, 0x74, 0xe4, 0x47, 0xd4, 0x85, 0x94, 0x0f, 0x47, 0x99, 0x5b,
	0xa0, 0x8c, 0x33, 0x77, 0xbd, 0x20, 0x4a, 0x7d, 0x50, 0x61, 0xa0, 0x29, 0x4d, 0x2b, 0x73, 0x94,
	0x26, 0xfa, 0x97, 0x92, 0x29, 0x28, 0xc7, 0x97, 0xfb, 0xcd, 0x42, 0xee, 0x37, 0x8a, 0xb9, 0xaf,
	0xcd, 0x9b, 0x2f, 0xff, 0x7f, 0x44, 0xea, 0x16, 0xcf, 0x4b, 0xd7, 0x46, 0xe3, 0xd0, 0xf2, 0x3c,
	0x0e, 0xfd, 0x53, 0x89, 0x38, 0x4d, 0x1e, 0x44, 0xf1, 0xf0, 0xf8, 0xfc, 0x79, 0xbf, 0xe0, 0xcf,
	0x8d, 0x9c, 0x04, 0xb4, 0x6e, 0x3e, 0x77, 0xfe, 0xa2, 0x4a, 0x08, 0xf2, 0x40, 0x45, 0x0d, 0x78,
	0x30, 0xab, 0xa2, 0x16, 0x48, 0x58, 0x51, 0x0b, 0x04, 0xca, 0x8a, 0x43, 0x61, 0x9e, 0x00, 0x4a,
	0xa3, 0xd4, 0xeb, 0xa9, 0x82, 0x2a, 0xe6, 0xc9, 0x80, 0x38, 0x4f, 0x06, 0xa2, 0x0c, 0xc9, 0x50,
	0x0c, 0x84, 0xcc, 0x84, 0x77, 0xec, 0x6a, 0xaa, 0x31, 0x2c, 0x06, 0x1a, 0xa1, 0xcc, 0x10, 0x35,
	0xf3, 0x7e, 0xcc, 0xb9, 0xaa, 0xa5, 0x86, 0x19, 0xb0, 0x3c, 0x33, 0x20, 0x8a, 0x19, 0x9a, 0x50,
	0x8a, 0xa1, 0x9d, 0x1c, 0x78, 0x31, 0xef, 0xa8, 0x32, 0x2a, 0x4a, 0x31, 0xa2, 0x58, 0x8a, 0x11,
	0xa3, 0xcc, 0x1a, 0xe0, 0xdc, 0x26, 0x75, 0xe8, 0xed, 0x0d, 0xf6, 0xf7, 0x79, 0x9c, 0xa8, 0x5a,
	0xfa, 0xc1, 0x28, 0x73, 0x6d, 0x78, 0x9c, 0xb9, 0x0e, 0x8a, 0x51, 0x20, 0x65, 0xf6, 0x10, 0x6d,
	0x4d, 0xdb, 0x6b, 0x1f, 0xf0, 0x8e, 0xaa, 0xa9, 0xc6, 0x1a, 0x89, 0xe6, 0xad, 0x91, 0x98, 0xb2,
	0x46, 0x76, 0x4c, 0xd0, 0x2f, 0xcd, 0x13, 0xf4, 0x7f, 0x2c, 0x91, 0xb5, 0x5b, 0x7e, 0x72, 0x78,
	0x7c, 0x21, 0x7f, 0xb7, 0x10, 0xf2, 0xeb, 0x39, 0x09, 0xda, 0xb6, 0xf9, 0x02, 0xfe, 0x67, 0x35,
	0xb2, 0xa4, 0x39, 0xe0, 0x2b, 0x44, 0x4c, 0xc8, 0x18, 0x17, 0x56, 0xa8, 0x78, 0x50, 0x56, 0xc8,
	0x58, 0xa8, 0xea, 0x38, 0x88, 0xb9, 0xd7, 0x69, 0xed, 0x0d, 0x53, 0x9e, 0xd8, 0x9b, 0x02, 0x44,
	0xd1, 0xf3, 0x88, 0x51, 0x66, 0x0d, 0x80, 0x3c, 0x10, 0x3d, 0xb3, 0xbf, 0x54, 0x79, 0x60, 0x40,
	0xcc, 0x03, 0x03, 0x51, 0x86, 0x64, 0x38, 0x7e, 0x42, 0x27, 0x51, 0x71, 0x2c, 0x8e, 0x9f, 0x02,
	0xc0, 0xe3, 0xa7, 0xe8, 0x52, 0x26, 0x61, 0x60, 0x90, 0x59, 0x57, 0x43, 0x06, 0x9d, 0x71, 0x8a,
	0x41, 0x65, 0x9b, 0x84, 0xc1, 0x29, 0x22, 0xcb, 0x16, 0xd0, 0x29, 0x2a, 0xc3, 0x94, 0x53, 0x64,
	0x76, 0x09, 0xd0, 0xb9, 0x47, 0x56, 0xe0, 0xb7, 0xd5, 0xe7, 0x71, 0x9b, 0x87, 0xa9, 0x0a, 0xc8,
	0xff, 0x1b, 0x65, 0x6e, 0x0e, 0x1f, 0x67, 0xee, 0x19, 0x64, 0xd6, 0x28, 0x65, 0xb9, 0x41, 0x90,
	0x24, 0x4f, 0xe1, 0x3c, 0xab, 0x5c, 0xbc, 0x84, 0x49, 0x62, 0xc1, 0x98, 0x24, 0x16, 0x48, 0x99,
	0x3d, 0x04, 0xa6, 0x4a, 0x76, 0x85, 0x9b, 0x97, 0x71, 0xaa, 0x10, 0xc5, 0xa9, 0x42, 0x8c, 0x32,
	0x6b, 0x80, 0x73, 0x83, 0x2c, 0x88, 0x5e, 0xa2, 0x56, 0x7f, 0x11, 0x5e, 0x12, 0xc1, 0xf0, 0x92,
	0x7d, 0xca, 0x14, 0xc1, 0x64, 0x56, 0x7d, 0xde, 0xf5, 0xf9, 0x01, 0x4f, 0x9f, 0x46, 0xf1, 0xe1,
	0x9b, 0xba, 0x3e, 0x5b, 0xe6, 0xcd, 0x97, 0x5f, 0xbf, 0x29, 0x93, 0xba, 0xc5, 0x04, 0xa5, 0x57,
	0xcc, 0x49, 0xcb, 0xd7, 0x4b, 0x89, 0x28, 0xbd, 0x1a, 0xc3, 0xd2, 0xab, 0x11, 0xca, 0x0c, 0x11,
	0xb2, 0x45, 0xb6, 0xa3, 0x41, 0x6a, 0xaf, 0x1a, 0x06, 0xc4, 0x6c, 0x31, 0x10, 0x65, 0x48, 0x76,
	0x3e, 0x26, 0x8b, 0xfd, 0xc3, 0x54, 0x28, 0x97, 0xc9, 0x26, 0x6e, 0x79, 0x14, 0x84, 0xb7, 0x3c,
	0x0a, 0xa0, 0x4c, 0x93, 0xc0, 0x6c, 0xd1, 0x04, 0xc5, 0xd6, 0x8a, 0xa1, 0x31, 0x34, 0x5b, 0x23,
	0x94, 0x19, 0xa2, 0x09, 0x82, 0xda, 0x3c, 0x41, 0xf0, 0xef, 0x12, 0x39, 0xbd, 0xdd, 0x1f, 0xb0,
	0x34, 0x17, 0x02, 0xb7, 0x60, 0xbd, 0x48, 0x63, 0xbf, 0xdd, 0xb2, 0x22, 0x41, 0xd5, 0x79, 0x80,
	0x1f, 0x78, 0x76, 0x08, 0x23, 0x26, 0xea, 0xbc, 0xee, 0xbc, 0xd0, 0xe6, 0xc6, 0xb9, 0x4d, 0x6a,
	0x62, 0x0e, 0x85, 0xa7, 0xea, 0xd7, 0xcf, 0x15, 0xf7, 0x69, 0xd2, 0x42, 0x75, 0xe1, 0x05, 0x03,
	0xad, 0x0b, 0x2f, 0xe8, 0x52, 0x26, 0x61, 0xbc, 0x5f, 0xae, 0xce, 0x73, 0xbf, 0xfc, 0xeb, 0x0a,
	0x59, 0x36, 0xd2, 0xdf, 0x1d, 0xe9, 0xde, 0xf8, 0x9b, 0x9a, 0x9f, 0x94, 0xc9, 0xba, 0xda, 0x81,
	0x1f, 0x7f, 0xcc, 0xde, 0xcb, 0xc7, 0xec, 0xe6, 0xb4, 0xb3, 0xc5, 0x6b, 0x8a, 0xdb, 0xef, 0x90,
	0x93, 0x39, 0x05, 0x2f, 0x7f, 0x4d, 0xf3, 0x45, 0x99, 0x9c, 0x95, 0x7b, 0xf1, 0xe3, 0x77, 0xec,
	0xdd, 0xbc, 0x63, 0xcf, 0x4f, 0x39, 0x64, 0xbc, 0x26, 0xbf, 0xfe, 0xab, 0x42, 0x56, 0x6c, 0x05,
	0xef, 0xce, 0x24, 0x5f, 0x8a, 0x33, 0x09, 0xfd, 0x4f, 0x89, 0x38, 0xb0, 0x31, 0x3f, 0xfe, 0xd8,
	0xff, 0x76, 0x3e, 0xf6, 0x37, 0x26, 0x4e, 0x1b, 0xaf, 0x29, 0xf2, 0x7f, 0x55, 0x25, 0x04, 0xc5,
	0x43, 0x78, 0x76, 0xfc, 0xe4, 0xb0, 0x65, 0x9d, 0x50, 0x44, 0x78, 0x1a, 0x10, 0xc3, 0xd3, 0x40,
	0x94, 0x21, 0x19, 0xa6, 0x45, 0x74, 0xec, 0x00, 0x17, 0x9e, 0x43, 0x14, 0x3d, 0x87, 0x18, 0x65,
	0xd6, 0x00, 0x63, 0x85, 0x15, 0xe4, 0x68, 0x85, 0x8a, 0x72, 0xdb, 0x0a, 0x19, 0xe6, 0x48, 0x76,
	0xbe, 0x47, 0xd6, 0x64, 0xc7, 0xca, 0x5f, 0x19, 0xef, 0xd7, 0x46, 0x99, 0x3b, 0x41, 0x1b, 0x67,
	0xee, 0x86, 0x2d, 0xce, 0xce, 0xe0, 0x89, 0xc1, 0xb0, 0xbf, 0x3b, 0xdc, 0x6b, 0xc1, 0x41, 0x47,
	0x25, 0x81, 0xd8, 0xdf, 0x29, 0x08, 0xf7, 0x77, 0x0a, 0xa0, 0x4c, 0x93, 0xc0, 0x37, 0x87, 0x7b,
	0x2d, 0xd8, 0xb4, 0xa7, 0x3c, 0x54, 0xa1, 0x2f, 0x7c, 0x83, 0x28, 0xfa, 0x06, 0x31, 0xca, 0xac,
	0x01, 0x90, 0xc2, 0x51, 0x3f, 0x91, 0xea, 0xad, 0xdb, 0x4d, 0x8d, 0x61, 0x0a, 0x6b, 0x84, 0x32,
	0x43, 0x04, 0xc7, 0x42, 0x5b, 0x9c, 0x1b, 0xd4, 0x51, 0x47, 0x38, 0xd6, 0x80, 0xe8, 0x58, 0x03,
	0x51, 0x86, 0x64, 0xb1, 0x10, 0xab, 0x9d, 0xf6, 0x1b, 0xbe, 0x10, 0xe7, 0xac, 0x7c, 0xe5, 0x69,
	0xf3, 0x45, 0x99, 0x9c, 0xcc, 0x69, 0xf8, 0x32, 0x9e, 0x39, 0x68, 0x44, 0x36, 0x9a, 0x51, 0xe8,
	0xa7, 0x51, 0xec, 0x87, 0xdd, 0xed, 0x28, 0xdc, 0xf7, 0xbb, 0xfa, 0xbf, 0xf1, 0x1d, 0x52, 0xf5,
	0x61, 0xd3, 0x5b, 0x12, 0x53, 0x73, 0x25, 0xbf, 0x94, 0x17, 0x78, 0xf0, 0xa0, 0xd7, 0x8e, 0x82,
	0x40, 0xa4, 0xa3, 0x3a, 0xe8, 0xc9, 0x3e, 0x65, 0x8a, 0x40, 0xfb, 0xa4, 0x31, 0xa9, 0x50, 0x05,
	0xe0, 0xeb, 0xd1, 0xf8, 0xbb, 0x0a, 0x39, 0x3b, 0x8d, 0xdb, 0x79, 0x4c, 0x4e, 0xa9, 0x27, 0x02,
	0x61, 0xca, 0xe3, 0x27, 0x5e, 0x4f, 0x28, 0xae, 0xc9, 0x9b, 0xf6, 0x3c, 0x05, 0x6f, 0xda, 0xf3,
	0x38, 0x65, 0x85, 0x81, 0x4e, 0x9b, 0x38, 0xed, 0xa8, 0xd7, 0xe3, 0xed, 0x34, 0x8a, 0x51, 0x70,
	0x59, 0x08, 0x16, 0xff, 0xda, 0x4f, 0x52, 0xf1, 0x5f, 0xfb, 0x49, 0x1a, 0x65, 0x53, 0x18, 0x9c,
	0x16, 0x39, 0x9d, 0xc0, 0xea, 0x37, 0xe8, 0x71, 0xd4, 0x51, 0x11, 0x3a, 0xbe, 0x3a, 0xca, 0xdc,
	0x49, 0xe2, 0x38, 0x73, 0x1b, 0xea, 0x61, 0x40, 0x91, 0x44, 0xd9, 0xe4, 0x70, 0x70, 0x4d, 0xe0,
	0xfd, 0xa0, 0x75, 0x10, 0x25, 0x69, 0xab, 0x1d, 0x0d, 0x42, 0x19, 0x59, 0xca, 0x35, 0x79, 0x0a,
	0xba, 0x26, 0x8f, 0x53, 0x56, 0x18, 0x08, 0x29, 0x22, 0x9d, 0x95, 0xa6, 0xf2, 0x5a, 0xa9, 0x26,
	0x53, 0x44, 0x82, 0x3b, 0x3b, 0xf7, 0x31, 0x45, 0x0c, 0x44, 0x19, 0x92, 0xe9, 0x3f, 0xca, 0xe4,
	0xdc, 0x9d, 0x30, 0x49, 0xbd, 0x5e, 0x6f, 0x87, 0xf7, 0x78, 0x37, 0xf6, 0xf6, 0xdf, 0x82, 0x87,
	0x1c, 0x9f, 0x92, 0xe5, 0xfe, 0x60, 0xaf, 0xe7, 0xb7, 0xf1, 0xed, 0x8a, 0xf8, 0x6c, 0x03, 0xe2,
	0x67, 0x1b, 0x88, 0x32, 0x24, 0x83, 0x80, 0x41, 0xc2, 0x63, 0x59, 0x95, 0x6b, 0x28, 0xc0, 0x80,
	0x28, 0xc0, 0x40, 0x94, 0x21, 0x19, 0xbe, 0x35, 0x49, 0x0e, 0x5a, 0x87, 0x7c, 0xa8, 0xde, 0x0b,
	0x89, 0x6f, 0x55, 0x10, 0x7e, 0xab, 0x02, 0x28, 0xd3, 0xa4, 0xeb, 0x7f, 0xad, 0x93, 0x4a, 0xf3,
	0xe1, 0x03, 0xa7, 0x4b, 0x36, 0x6e, 0xf3, 0x34, 0xf7, 0x6c, 0x48, 0xff, 0x99, 0xfa, 0x7e, 0x2e,
	0x4b, 0x67, 0xbc, 0x2c, 0xda, 0x7c, 0xff, 0xa8, 0x07, 0x1a, 0x3a, 0xff, 0xe9, 0x09, 0x27, 0x22,
	0x17, 0xa6, 0x28, 0x32, 0x7f, 0xdb, 0xcc, 0xa7, 0xec, 0xea, 0xb4, 0xe3, 0xdc, 0x0c, 0x85, 0x0f,
	0xc9, 0xaa, 0x50, 0x68, 0x7d, 0xd1, 0xc5, 0x82, 0x92, 0xbc, 0xf0, 0x8b, 0xd3, 0xfe, 0x83, 0xb6,
	0x04, 0x7e, 0x46, 0xce, 0x58, 0x02, 0x8d, 0xe5, 0x47, 0x0b, 0xbd, 0x3c, 0xeb, 0xcf, 0x2d, 0x4b,
	0xf0, 0x77, 0x89, 0xa3, 0x05, 0x5b, 0xff, 0xbc, 0x1c, 0x2d, 0xd7, 0x9d, 0xf1, 0x27, 0x8f, 0x25,
	0xf6, 0x11, 0x59, 0xd3, 0x62, 0xcd, 0xfd, 0xf6, 0xd1, 0x42, 0x2f, 0x4d, 0xbd, 0x46, 0x9f, 0xee,
	0x02, 0xfb, 0x4a, 0xef, 0x45, 0x5c, 0x30, 0xe5, 0x7a, 0x93, 0x9e, 0x70, 0xbe, 0x4f, 0xd6, 0x85,
	0x60, 0xf3, 0x92, 0x4b, 0x4f, 0x19, 0x2d, 0x88, 0x9e, 0xf2, 0xd4, 0x6b, 0x73, 0x6b, 0xfa, 0xc5,
	0x94, 0x25, 0x9e, 0x93, 0xf3, 0x13, 0xe2, 0xcd, 0x04, 0xce, 0xa3, 0x82, 0xce, 0xbe, 0x47, 0xb0,
	0xd4, 0xb4, 0x49, 0x23, 0xaf, 0xc6, 0x9a, 0xce, 0x79, 0xb4, 0x5c, 0x99, 0x79, 0xa8, 0xb6, 0x94,
	0xb4, 0xc8, 0xb9, 0xbc, 0x12, 0x33, 0xb9, 0xf3, 0xa8, 0x70, 0x67, 0x9c, 0x5d, 0x8e, 0x72, 0x96,
	0x3d, 0xd5, 0x2f, 0xee, 0xac, 0xa9, 0x3b, 0x52, 0x31, 0xe5, 0x2b, 0x8f, 0xb9, 0x98, 0x0b, 0xb1,
	0x6e, 0x17, 0x2a, 0xc0, 0x8c, 0xad, 0xcb, 0xe6, 0x07, 0xff, 0x63, 0x94, 0x11, 0x7f, 0x8f, 0xac,
	0xdc, 0xb6, 0xc5, 0x3b, 0x39, 0x46, 0xf1, 0x60, 0x77, 0x7e, 0x61, 0x4d, 0x72, 0x8a, 0xf1, 0xe4,
	0x95, 0x89, 0xdb, 0x25, 0xab, 0x85, 0xc5, 0xce, 0x79, 0x2f, 0xc7, 0x3b, 0x7d, 0x29, 0x2c, 0x54,
	0xa8, 0xc2, 0x5b, 0x63, 0x7a, 0xe2, 0xe6, 0xda, 0xef, 0x9f, 0x6f, 0x95, 0xfe, 0xfc, 0x7c, 0xab,
	0xf4, 0xb7, 0xe7, 0x5b, 0xa5, 0x67, 0x7f, 0xdf, 0x3a, 0xb1, 0xb7, 0x20, 0x9e, 0x28, 0xdf, 0xf8,
	0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3b, 0xeb, 0x3e, 0xbe, 0xe6, 0x2c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MONClient is the client API for MON service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MONClient interface {
	// VM 온디멘드 모니터링 조회
	GetVMOndemandMonCpuInfo(ctx context.Context, in *VMOndemandMonQryRequest, opts ...grpc.CallOption) (*CpuOndemandInfoResponse, error)
	GetVMOndemandMonCpuFreqInfo(ctx context.Context, in *VMOndemandMonQryRequest, opts ...grpc.CallOption) (*CpuFreqOndemandInfoResponse, error)
	// VM 모니터링 조회
	GetVMMonCpuInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*CpuInfoResponse, error)
	GetVMMonCpuFreqInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*CpuFreqInfoResponse, error)
	GetVMMonMemoryInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*MemoryInfoResponse, error)
	GetVMMonDiskInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*DiskInfoResponse, error)
	GetVMMonNetworkInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*NetworkInfoResponse, error)
	GetVMLatestMonCpuInfo(ctx context.Context, in *VMLatestMonQryRequest, opts ...grpc.CallOption) (*CpuRtInfoResponse, error)
	GetVMLatestMonCpuFreqInfo(ctx context.Context, in *VMLatestMonQryRequest, opts ...grpc.CallOption) (*CpuFreqRtInfoResponse, error)
	GetVMLatestMonMemoryInfo(ctx context.Context, in *VMLatestMonQryRequest, opts ...grpc.CallOption) (*MemoryRtInfoResponse, error)
	GetVMLatestMonDiskInfo(ctx context.Context, in *VMLatestMonQryRequest, opts ...grpc.CallOption) (*DiskRtInfoResponse, error)
	GetVMLatestMonNetworkInfo(ctx context.Context, in *VMLatestMonQryRequest, opts ...grpc.CallOption) (*NetworkRtInfoResponse, error)
	SetMonConfig(ctx context.Context, in *MonitoringConfigRequest, opts ...grpc.CallOption) (*MonitoringConfigResponse, error)
	GetMonConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MonitoringConfigResponse, error)
	ResetMonConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MonitoringConfigResponse, error)
	InstallTelegraf(ctx context.Context, in *InstallTelegrafRequest, opts ...grpc.CallOption) (*MessageResponse, error)
}

type mONClient struct {
	cc *grpc.ClientConn
}

func NewMONClient(cc *grpc.ClientConn) MONClient {
	return &mONClient{cc}
}

func (c *mONClient) GetVMOndemandMonCpuInfo(ctx context.Context, in *VMOndemandMonQryRequest, opts ...grpc.CallOption) (*CpuOndemandInfoResponse, error) {
	out := new(CpuOndemandInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMOndemandMonCpuInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMOndemandMonCpuFreqInfo(ctx context.Context, in *VMOndemandMonQryRequest, opts ...grpc.CallOption) (*CpuFreqOndemandInfoResponse, error) {
	out := new(CpuFreqOndemandInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMOndemandMonCpuFreqInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMMonCpuInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*CpuInfoResponse, error) {
	out := new(CpuInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMMonCpuInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMMonCpuFreqInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*CpuFreqInfoResponse, error) {
	out := new(CpuFreqInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMMonCpuFreqInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMMonMemoryInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*MemoryInfoResponse, error) {
	out := new(MemoryInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMMonMemoryInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMMonDiskInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*DiskInfoResponse, error) {
	out := new(DiskInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMMonDiskInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMMonNetworkInfo(ctx context.Context, in *VMMonQryRequest, opts ...grpc.CallOption) (*NetworkInfoResponse, error) {
	out := new(NetworkInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMMonNetworkInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMLatestMonCpuInfo(ctx context.Context, in *VMLatestMonQryRequest, opts ...grpc.CallOption) (*CpuRtInfoResponse, error) {
	out := new(CpuRtInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMLatestMonCpuInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMLatestMonCpuFreqInfo(ctx context.Context, in *VMLatestMonQryRequest, opts ...grpc.CallOption) (*CpuFreqRtInfoResponse, error) {
	out := new(CpuFreqRtInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMLatestMonCpuFreqInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMLatestMonMemoryInfo(ctx context.Context, in *VMLatestMonQryRequest, opts ...grpc.CallOption) (*MemoryRtInfoResponse, error) {
	out := new(MemoryRtInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMLatestMonMemoryInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMLatestMonDiskInfo(ctx context.Context, in *VMLatestMonQryRequest, opts ...grpc.CallOption) (*DiskRtInfoResponse, error) {
	out := new(DiskRtInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMLatestMonDiskInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetVMLatestMonNetworkInfo(ctx context.Context, in *VMLatestMonQryRequest, opts ...grpc.CallOption) (*NetworkRtInfoResponse, error) {
	out := new(NetworkRtInfoResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetVMLatestMonNetworkInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) SetMonConfig(ctx context.Context, in *MonitoringConfigRequest, opts ...grpc.CallOption) (*MonitoringConfigResponse, error) {
	out := new(MonitoringConfigResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/SetMonConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) GetMonConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MonitoringConfigResponse, error) {
	out := new(MonitoringConfigResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/GetMonConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) ResetMonConfig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*MonitoringConfigResponse, error) {
	out := new(MonitoringConfigResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/ResetMonConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mONClient) InstallTelegraf(ctx context.Context, in *InstallTelegrafRequest, opts ...grpc.CallOption) (*MessageResponse, error) {
	out := new(MessageResponse)
	err := c.cc.Invoke(ctx, "/cbdragonfly.MON/InstallTelegraf", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MONServer is the server API for MON service.
type MONServer interface {
	// VM 온디멘드 모니터링 조회
	GetVMOndemandMonCpuInfo(context.Context, *VMOndemandMonQryRequest) (*CpuOndemandInfoResponse, error)
	GetVMOndemandMonCpuFreqInfo(context.Context, *VMOndemandMonQryRequest) (*CpuFreqOndemandInfoResponse, error)
	// VM 모니터링 조회
	GetVMMonCpuInfo(context.Context, *VMMonQryRequest) (*CpuInfoResponse, error)
	GetVMMonCpuFreqInfo(context.Context, *VMMonQryRequest) (*CpuFreqInfoResponse, error)
	GetVMMonMemoryInfo(context.Context, *VMMonQryRequest) (*MemoryInfoResponse, error)
	GetVMMonDiskInfo(context.Context, *VMMonQryRequest) (*DiskInfoResponse, error)
	GetVMMonNetworkInfo(context.Context, *VMMonQryRequest) (*NetworkInfoResponse, error)
	GetVMLatestMonCpuInfo(context.Context, *VMLatestMonQryRequest) (*CpuRtInfoResponse, error)
	GetVMLatestMonCpuFreqInfo(context.Context, *VMLatestMonQryRequest) (*CpuFreqRtInfoResponse, error)
	GetVMLatestMonMemoryInfo(context.Context, *VMLatestMonQryRequest) (*MemoryRtInfoResponse, error)
	GetVMLatestMonDiskInfo(context.Context, *VMLatestMonQryRequest) (*DiskRtInfoResponse, error)
	GetVMLatestMonNetworkInfo(context.Context, *VMLatestMonQryRequest) (*NetworkRtInfoResponse, error)
	SetMonConfig(context.Context, *MonitoringConfigRequest) (*MonitoringConfigResponse, error)
	GetMonConfig(context.Context, *Empty) (*MonitoringConfigResponse, error)
	ResetMonConfig(context.Context, *Empty) (*MonitoringConfigResponse, error)
	InstallTelegraf(context.Context, *InstallTelegrafRequest) (*MessageResponse, error)
}

// UnimplementedMONServer can be embedded to have forward compatible implementations.
type UnimplementedMONServer struct {
}

func (*UnimplementedMONServer) GetVMOndemandMonCpuInfo(ctx context.Context, req *VMOndemandMonQryRequest) (*CpuOndemandInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMOndemandMonCpuInfo not implemented")
}
func (*UnimplementedMONServer) GetVMOndemandMonCpuFreqInfo(ctx context.Context, req *VMOndemandMonQryRequest) (*CpuFreqOndemandInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMOndemandMonCpuFreqInfo not implemented")
}
func (*UnimplementedMONServer) GetVMMonCpuInfo(ctx context.Context, req *VMMonQryRequest) (*CpuInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMonCpuInfo not implemented")
}
func (*UnimplementedMONServer) GetVMMonCpuFreqInfo(ctx context.Context, req *VMMonQryRequest) (*CpuFreqInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMonCpuFreqInfo not implemented")
}
func (*UnimplementedMONServer) GetVMMonMemoryInfo(ctx context.Context, req *VMMonQryRequest) (*MemoryInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMonMemoryInfo not implemented")
}
func (*UnimplementedMONServer) GetVMMonDiskInfo(ctx context.Context, req *VMMonQryRequest) (*DiskInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMonDiskInfo not implemented")
}
func (*UnimplementedMONServer) GetVMMonNetworkInfo(ctx context.Context, req *VMMonQryRequest) (*NetworkInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMMonNetworkInfo not implemented")
}
func (*UnimplementedMONServer) GetVMLatestMonCpuInfo(ctx context.Context, req *VMLatestMonQryRequest) (*CpuRtInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMLatestMonCpuInfo not implemented")
}
func (*UnimplementedMONServer) GetVMLatestMonCpuFreqInfo(ctx context.Context, req *VMLatestMonQryRequest) (*CpuFreqRtInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMLatestMonCpuFreqInfo not implemented")
}
func (*UnimplementedMONServer) GetVMLatestMonMemoryInfo(ctx context.Context, req *VMLatestMonQryRequest) (*MemoryRtInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMLatestMonMemoryInfo not implemented")
}
func (*UnimplementedMONServer) GetVMLatestMonDiskInfo(ctx context.Context, req *VMLatestMonQryRequest) (*DiskRtInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMLatestMonDiskInfo not implemented")
}
func (*UnimplementedMONServer) GetVMLatestMonNetworkInfo(ctx context.Context, req *VMLatestMonQryRequest) (*NetworkRtInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVMLatestMonNetworkInfo not implemented")
}
func (*UnimplementedMONServer) SetMonConfig(ctx context.Context, req *MonitoringConfigRequest) (*MonitoringConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMonConfig not implemented")
}
func (*UnimplementedMONServer) GetMonConfig(ctx context.Context, req *Empty) (*MonitoringConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMonConfig not implemented")
}
func (*UnimplementedMONServer) ResetMonConfig(ctx context.Context, req *Empty) (*MonitoringConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetMonConfig not implemented")
}
func (*UnimplementedMONServer) InstallTelegraf(ctx context.Context, req *InstallTelegrafRequest) (*MessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallTelegraf not implemented")
}

func RegisterMONServer(s *grpc.Server, srv MONServer) {
	s.RegisterService(&_MON_serviceDesc, srv)
}

func _MON_GetVMOndemandMonCpuInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMOndemandMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMOndemandMonCpuInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMOndemandMonCpuInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMOndemandMonCpuInfo(ctx, req.(*VMOndemandMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMOndemandMonCpuFreqInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMOndemandMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMOndemandMonCpuFreqInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMOndemandMonCpuFreqInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMOndemandMonCpuFreqInfo(ctx, req.(*VMOndemandMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMMonCpuInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMMonCpuInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMMonCpuInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMMonCpuInfo(ctx, req.(*VMMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMMonCpuFreqInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMMonCpuFreqInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMMonCpuFreqInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMMonCpuFreqInfo(ctx, req.(*VMMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMMonMemoryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMMonMemoryInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMMonMemoryInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMMonMemoryInfo(ctx, req.(*VMMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMMonDiskInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMMonDiskInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMMonDiskInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMMonDiskInfo(ctx, req.(*VMMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMMonNetworkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMMonNetworkInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMMonNetworkInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMMonNetworkInfo(ctx, req.(*VMMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMLatestMonCpuInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMLatestMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMLatestMonCpuInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMLatestMonCpuInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMLatestMonCpuInfo(ctx, req.(*VMLatestMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMLatestMonCpuFreqInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMLatestMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMLatestMonCpuFreqInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMLatestMonCpuFreqInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMLatestMonCpuFreqInfo(ctx, req.(*VMLatestMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMLatestMonMemoryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMLatestMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMLatestMonMemoryInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMLatestMonMemoryInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMLatestMonMemoryInfo(ctx, req.(*VMLatestMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMLatestMonDiskInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMLatestMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMLatestMonDiskInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMLatestMonDiskInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMLatestMonDiskInfo(ctx, req.(*VMLatestMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetVMLatestMonNetworkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VMLatestMonQryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetVMLatestMonNetworkInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetVMLatestMonNetworkInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetVMLatestMonNetworkInfo(ctx, req.(*VMLatestMonQryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_SetMonConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MonitoringConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).SetMonConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/SetMonConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).SetMonConfig(ctx, req.(*MonitoringConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_GetMonConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).GetMonConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/GetMonConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).GetMonConfig(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_ResetMonConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).ResetMonConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/ResetMonConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).ResetMonConfig(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MON_InstallTelegraf_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallTelegrafRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MONServer).InstallTelegraf(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cbdragonfly.MON/InstallTelegraf",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MONServer).InstallTelegraf(ctx, req.(*InstallTelegrafRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MON_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cbdragonfly.MON",
	HandlerType: (*MONServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVMOndemandMonCpuInfo",
			Handler:    _MON_GetVMOndemandMonCpuInfo_Handler,
		},
		{
			MethodName: "GetVMOndemandMonCpuFreqInfo",
			Handler:    _MON_GetVMOndemandMonCpuFreqInfo_Handler,
		},
		{
			MethodName: "GetVMMonCpuInfo",
			Handler:    _MON_GetVMMonCpuInfo_Handler,
		},
		{
			MethodName: "GetVMMonCpuFreqInfo",
			Handler:    _MON_GetVMMonCpuFreqInfo_Handler,
		},
		{
			MethodName: "GetVMMonMemoryInfo",
			Handler:    _MON_GetVMMonMemoryInfo_Handler,
		},
		{
			MethodName: "GetVMMonDiskInfo",
			Handler:    _MON_GetVMMonDiskInfo_Handler,
		},
		{
			MethodName: "GetVMMonNetworkInfo",
			Handler:    _MON_GetVMMonNetworkInfo_Handler,
		},
		{
			MethodName: "GetVMLatestMonCpuInfo",
			Handler:    _MON_GetVMLatestMonCpuInfo_Handler,
		},
		{
			MethodName: "GetVMLatestMonCpuFreqInfo",
			Handler:    _MON_GetVMLatestMonCpuFreqInfo_Handler,
		},
		{
			MethodName: "GetVMLatestMonMemoryInfo",
			Handler:    _MON_GetVMLatestMonMemoryInfo_Handler,
		},
		{
			MethodName: "GetVMLatestMonDiskInfo",
			Handler:    _MON_GetVMLatestMonDiskInfo_Handler,
		},
		{
			MethodName: "GetVMLatestMonNetworkInfo",
			Handler:    _MON_GetVMLatestMonNetworkInfo_Handler,
		},
		{
			MethodName: "SetMonConfig",
			Handler:    _MON_SetMonConfig_Handler,
		},
		{
			MethodName: "GetMonConfig",
			Handler:    _MON_GetMonConfig_Handler,
		},
		{
			MethodName: "ResetMonConfig",
			Handler:    _MON_ResetMonConfig_Handler,
		},
		{
			MethodName: "InstallTelegraf",
			Handler:    _MON_InstallTelegraf_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cbdragonfly/cbdragonfly.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *MessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tags) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tags) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.McisId) > 0 {
		i -= len(m.McisId)
		copy(dAtA[i:], m.McisId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.McisId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NsId) > 0 {
		i -= len(m.NsId)
		copy(dAtA[i:], m.NsId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.NsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VMMonQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VMMonQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VMMonQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Duration) > 0 {
		i -= len(m.Duration)
		copy(dAtA[i:], m.Duration)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Duration)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StatisticsCriteria) > 0 {
		i -= len(m.StatisticsCriteria)
		copy(dAtA[i:], m.StatisticsCriteria)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.StatisticsCriteria)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PeriodType) > 0 {
		i -= len(m.PeriodType)
		copy(dAtA[i:], m.PeriodType)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.PeriodType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.McisId) > 0 {
		i -= len(m.McisId)
		copy(dAtA[i:], m.McisId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.McisId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NsId) > 0 {
		i -= len(m.NsId)
		copy(dAtA[i:], m.NsId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.NsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VMOndemandMonQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VMOndemandMonQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VMOndemandMonQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AgentIp) > 0 {
		i -= len(m.AgentIp)
		copy(dAtA[i:], m.AgentIp)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.AgentIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.McisId) > 0 {
		i -= len(m.McisId)
		copy(dAtA[i:], m.McisId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.McisId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NsId) > 0 {
		i -= len(m.NsId)
		copy(dAtA[i:], m.NsId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.NsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VMLatestMonQryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VMLatestMonQryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VMLatestMonQryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StatisticsCriteria) > 0 {
		i -= len(m.StatisticsCriteria)
		copy(dAtA[i:], m.StatisticsCriteria)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.StatisticsCriteria)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.McisId) > 0 {
		i -= len(m.McisId)
		copy(dAtA[i:], m.McisId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.McisId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NsId) > 0 {
		i -= len(m.NsId)
		copy(dAtA[i:], m.NsId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.NsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuOndemandInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuOndemandInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuOndemandInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuOndemandInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuOndemandInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuOndemandInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CpuSintr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSintr))))
		i--
		dAtA[i] = 0x31
	}
	if m.CpuHintr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuHintr))))
		i--
		dAtA[i] = 0x29
	}
	if m.CpuIowait != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuIowait))))
		i--
		dAtA[i] = 0x21
	}
	if m.CpuIdle != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuIdle))))
		i--
		dAtA[i] = 0x19
	}
	if m.CpuSystem != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSystem))))
		i--
		dAtA[i] = 0x11
	}
	if m.CpuUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUtilization))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CpuFreqOndemandInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuFreqOndemandInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuFreqOndemandInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuFreqOndemandInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuFreqOndemandInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuFreqOndemandInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CpuSpeed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSpeed))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CpuInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x62
	}
	if m.CpuGuestNice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuGuestNice))))
		i--
		dAtA[i] = 0x59
	}
	if m.CpuGuest != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuGuest))))
		i--
		dAtA[i] = 0x51
	}
	if m.CpuSteal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSteal))))
		i--
		dAtA[i] = 0x49
	}
	if m.CpuNice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuNice))))
		i--
		dAtA[i] = 0x41
	}
	if m.CpuUser != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUser))))
		i--
		dAtA[i] = 0x39
	}
	if m.CpuSintr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSintr))))
		i--
		dAtA[i] = 0x31
	}
	if m.CpuHintr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuHintr))))
		i--
		dAtA[i] = 0x29
	}
	if m.CpuIowait != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuIowait))))
		i--
		dAtA[i] = 0x21
	}
	if m.CpuIdle != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuIdle))))
		i--
		dAtA[i] = 0x19
	}
	if m.CpuSystem != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSystem))))
		i--
		dAtA[i] = 0x11
	}
	if m.CpuUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUtilization))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CpuFreqInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuFreqInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuFreqInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuFreqInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuFreqInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuFreqInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x12
	}
	if m.CpuSpeed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSpeed))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MemoryInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x42
	}
	if m.MemCached != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemCached))))
		i--
		dAtA[i] = 0x39
	}
	if m.MemBuffers != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemBuffers))))
		i--
		dAtA[i] = 0x31
	}
	if m.MemShared != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemShared))))
		i--
		dAtA[i] = 0x29
	}
	if m.MemFree != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemFree))))
		i--
		dAtA[i] = 0x21
	}
	if m.MemUsed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemUsed))))
		i--
		dAtA[i] = 0x19
	}
	if m.MemTotal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemTotal))))
		i--
		dAtA[i] = 0x11
	}
	if m.MemUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemUtilization))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DiskInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Writes != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Writes))))
		i--
		dAtA[i] = 0x51
	}
	if m.WriteTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WriteTime))))
		i--
		dAtA[i] = 0x49
	}
	if m.WriteBytes != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.WriteBytes))))
		i--
		dAtA[i] = 0x41
	}
	if m.UsedPercent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.UsedPercent))))
		i--
		dAtA[i] = 0x39
	}
	if m.Used != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Used))))
		i--
		dAtA[i] = 0x31
	}
	if m.Total != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Total))))
		i--
		dAtA[i] = 0x29
	}
	if m.Reads != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Reads))))
		i--
		dAtA[i] = 0x21
	}
	if m.ReadTime != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReadTime))))
		i--
		dAtA[i] = 0x19
	}
	if m.ReadBytes != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ReadBytes))))
		i--
		dAtA[i] = 0x11
	}
	if m.Free != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Free))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tags != nil {
		{
			size, err := m.Tags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PktsOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PktsOut))))
		i--
		dAtA[i] = 0x21
	}
	if m.PktsIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PktsIn))))
		i--
		dAtA[i] = 0x19
	}
	if m.BytesOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BytesOut))))
		i--
		dAtA[i] = 0x11
	}
	if m.BytesIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BytesIn))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CpuRtInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuRtInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuRtInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MetricName) > 0 {
		i -= len(m.MetricName)
		copy(dAtA[i:], m.MetricName)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.MetricName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuRtInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuRtInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuRtInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CpuSintr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSintr))))
		i--
		dAtA[i] = 0x31
	}
	if m.CpuHintr != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuHintr))))
		i--
		dAtA[i] = 0x29
	}
	if m.CpuIowait != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuIowait))))
		i--
		dAtA[i] = 0x21
	}
	if m.CpuIdle != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuIdle))))
		i--
		dAtA[i] = 0x19
	}
	if m.CpuSystem != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSystem))))
		i--
		dAtA[i] = 0x11
	}
	if m.CpuUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuUtilization))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *CpuFreqRtInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuFreqRtInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuFreqRtInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MetricName) > 0 {
		i -= len(m.MetricName)
		copy(dAtA[i:], m.MetricName)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.MetricName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CpuFreqRtInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CpuFreqRtInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CpuFreqRtInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CpuSpeed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuSpeed))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MemoryRtInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryRtInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryRtInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MetricName) > 0 {
		i -= len(m.MetricName)
		copy(dAtA[i:], m.MetricName)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.MetricName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemoryRtInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryRtInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryRtInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MemCached != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemCached))))
		i--
		dAtA[i] = 0x39
	}
	if m.MemBuffers != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemBuffers))))
		i--
		dAtA[i] = 0x31
	}
	if m.MemShared != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemShared))))
		i--
		dAtA[i] = 0x29
	}
	if m.MemFree != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemFree))))
		i--
		dAtA[i] = 0x21
	}
	if m.MemUsed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemUsed))))
		i--
		dAtA[i] = 0x19
	}
	if m.MemTotal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemTotal))))
		i--
		dAtA[i] = 0x11
	}
	if m.MemUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MemUtilization))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *DiskRtInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskRtInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskRtInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MetricName) > 0 {
		i -= len(m.MetricName)
		copy(dAtA[i:], m.MetricName)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.MetricName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiskRtInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskRtInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskRtInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OpsWrite != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OpsWrite))))
		i--
		dAtA[i] = 0x41
	}
	if m.OpsRead != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.OpsRead))))
		i--
		dAtA[i] = 0x39
	}
	if m.KbWritten != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.KbWritten))))
		i--
		dAtA[i] = 0x31
	}
	if m.KbRead != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.KbRead))))
		i--
		dAtA[i] = 0x29
	}
	if m.DiskUtilization != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiskUtilization))))
		i--
		dAtA[i] = 0x21
	}
	if m.DiskUsed != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiskUsed))))
		i--
		dAtA[i] = 0x19
	}
	if m.DiskTotal != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiskTotal))))
		i--
		dAtA[i] = 0x11
	}
	if m.DiskFree != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DiskFree))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *NetworkRtInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkRtInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkRtInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MetricName) > 0 {
		i -= len(m.MetricName)
		copy(dAtA[i:], m.MetricName)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.MetricName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkRtInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkRtInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkRtInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PktsOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PktsOut))))
		i--
		dAtA[i] = 0x21
	}
	if m.PktsIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PktsIn))))
		i--
		dAtA[i] = 0x19
	}
	if m.BytesOut != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BytesOut))))
		i--
		dAtA[i] = 0x11
	}
	if m.BytesIn != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BytesIn))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MonitoringConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitoringConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonitoringConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MonitoringConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitoringConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonitoringConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbdragonfly(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MonitoringConfigInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonitoringConfigInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonitoringConfigInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AgentTtl != 0 {
		i = encodeVarintCbdragonfly(dAtA, i, uint64(m.AgentTtl))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxHostCount != 0 {
		i = encodeVarintCbdragonfly(dAtA, i, uint64(m.MaxHostCount))
		i--
		dAtA[i] = 0x20
	}
	if m.ScheduleInterval != 0 {
		i = encodeVarintCbdragonfly(dAtA, i, uint64(m.ScheduleInterval))
		i--
		dAtA[i] = 0x18
	}
	if m.CollectorInterval != 0 {
		i = encodeVarintCbdragonfly(dAtA, i, uint64(m.CollectorInterval))
		i--
		dAtA[i] = 0x10
	}
	if m.AgentInterval != 0 {
		i = encodeVarintCbdragonfly(dAtA, i, uint64(m.AgentInterval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InstallTelegrafRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallTelegrafRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallTelegrafRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SshKey) > 0 {
		i -= len(m.SshKey)
		copy(dAtA[i:], m.SshKey)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.SshKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicIp) > 0 {
		i -= len(m.PublicIp)
		copy(dAtA[i:], m.PublicIp)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.PublicIp)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VmId) > 0 {
		i -= len(m.VmId)
		copy(dAtA[i:], m.VmId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.VmId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.McisId) > 0 {
		i -= len(m.McisId)
		copy(dAtA[i:], m.McisId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.McisId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NsId) > 0 {
		i -= len(m.NsId)
		copy(dAtA[i:], m.NsId)
		i = encodeVarintCbdragonfly(dAtA, i, uint64(len(m.NsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCbdragonfly(dAtA []byte, offset int, v uint64) int {
	offset -= sovCbdragonfly(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MessageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.McisId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VMMonQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.McisId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.PeriodType)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.StatisticsCriteria)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Duration)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VMOndemandMonQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.McisId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.AgentIp)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VMLatestMonQryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.McisId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.StatisticsCriteria)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuOndemandInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuOndemandInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuUtilization != 0 {
		n += 9
	}
	if m.CpuSystem != 0 {
		n += 9
	}
	if m.CpuIdle != 0 {
		n += 9
	}
	if m.CpuIowait != 0 {
		n += 9
	}
	if m.CpuHintr != 0 {
		n += 9
	}
	if m.CpuSintr != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuFreqOndemandInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuFreqOndemandInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuSpeed != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuUtilization != 0 {
		n += 9
	}
	if m.CpuSystem != 0 {
		n += 9
	}
	if m.CpuIdle != 0 {
		n += 9
	}
	if m.CpuIowait != 0 {
		n += 9
	}
	if m.CpuHintr != 0 {
		n += 9
	}
	if m.CpuSintr != 0 {
		n += 9
	}
	if m.CpuUser != 0 {
		n += 9
	}
	if m.CpuNice != 0 {
		n += 9
	}
	if m.CpuSteal != 0 {
		n += 9
	}
	if m.CpuGuest != 0 {
		n += 9
	}
	if m.CpuGuestNice != 0 {
		n += 9
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuFreqInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuFreqInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuSpeed != 0 {
		n += 9
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemUtilization != 0 {
		n += 9
	}
	if m.MemTotal != 0 {
		n += 9
	}
	if m.MemUsed != 0 {
		n += 9
	}
	if m.MemFree != 0 {
		n += 9
	}
	if m.MemShared != 0 {
		n += 9
	}
	if m.MemBuffers != 0 {
		n += 9
	}
	if m.MemCached != 0 {
		n += 9
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Free != 0 {
		n += 9
	}
	if m.ReadBytes != 0 {
		n += 9
	}
	if m.ReadTime != 0 {
		n += 9
	}
	if m.Reads != 0 {
		n += 9
	}
	if m.Total != 0 {
		n += 9
	}
	if m.Used != 0 {
		n += 9
	}
	if m.UsedPercent != 0 {
		n += 9
	}
	if m.WriteBytes != 0 {
		n += 9
	}
	if m.WriteTime != 0 {
		n += 9
	}
	if m.Writes != 0 {
		n += 9
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Tags != nil {
		l = m.Tags.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovCbdragonfly(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesIn != 0 {
		n += 9
	}
	if m.BytesOut != 0 {
		n += 9
	}
	if m.PktsIn != 0 {
		n += 9
	}
	if m.PktsOut != 0 {
		n += 9
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuRtInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetricName)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuRtInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuUtilization != 0 {
		n += 9
	}
	if m.CpuSystem != 0 {
		n += 9
	}
	if m.CpuIdle != 0 {
		n += 9
	}
	if m.CpuIowait != 0 {
		n += 9
	}
	if m.CpuHintr != 0 {
		n += 9
	}
	if m.CpuSintr != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuFreqRtInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetricName)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CpuFreqRtInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuSpeed != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryRtInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetricName)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MemoryRtInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemUtilization != 0 {
		n += 9
	}
	if m.MemTotal != 0 {
		n += 9
	}
	if m.MemUsed != 0 {
		n += 9
	}
	if m.MemFree != 0 {
		n += 9
	}
	if m.MemShared != 0 {
		n += 9
	}
	if m.MemBuffers != 0 {
		n += 9
	}
	if m.MemCached != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskRtInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetricName)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskRtInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiskFree != 0 {
		n += 9
	}
	if m.DiskTotal != 0 {
		n += 9
	}
	if m.DiskUsed != 0 {
		n += 9
	}
	if m.DiskUtilization != 0 {
		n += 9
	}
	if m.KbRead != 0 {
		n += 9
	}
	if m.KbWritten != 0 {
		n += 9
	}
	if m.OpsRead != 0 {
		n += 9
	}
	if m.OpsWrite != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkRtInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetricName)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NetworkRtInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesIn != 0 {
		n += 9
	}
	if m.BytesOut != 0 {
		n += 9
	}
	if m.PktsIn != 0 {
		n += 9
	}
	if m.PktsOut != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MonitoringConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MonitoringConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MonitoringConfigInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentInterval != 0 {
		n += 1 + sovCbdragonfly(uint64(m.AgentInterval))
	}
	if m.CollectorInterval != 0 {
		n += 1 + sovCbdragonfly(uint64(m.CollectorInterval))
	}
	if m.ScheduleInterval != 0 {
		n += 1 + sovCbdragonfly(uint64(m.ScheduleInterval))
	}
	if m.MaxHostCount != 0 {
		n += 1 + sovCbdragonfly(uint64(m.MaxHostCount))
	}
	if m.AgentTtl != 0 {
		n += 1 + sovCbdragonfly(uint64(m.AgentTtl))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallTelegrafRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NsId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.McisId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.VmId)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.PublicIp)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	l = len(m.SshKey)
	if l > 0 {
		n += 1 + l + sovCbdragonfly(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCbdragonfly(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCbdragonfly(x uint64) (n int) {
	return sovCbdragonfly(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McisId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McisId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMMonQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMMonQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMMonQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McisId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McisId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeriodType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatisticsCriteria", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatisticsCriteria = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Duration = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMOndemandMonQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMOndemandMonQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMOndemandMonQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McisId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McisId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VMLatestMonQryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VMLatestMonQryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VMLatestMonQryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McisId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McisId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatisticsCriteria", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatisticsCriteria = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuOndemandInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuOndemandInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuOndemandInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &CpuOndemandInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuOndemandInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuOndemandInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuOndemandInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUtilization = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSystem", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSystem = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIdle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuIdle = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIowait", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuIowait = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuHintr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuHintr = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSintr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSintr = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuFreqOndemandInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuFreqOndemandInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuFreqOndemandInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &CpuInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuFreqOndemandInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuFreqOndemandInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuFreqOndemandInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSpeed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSpeed = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &CpuInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUtilization = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSystem", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSystem = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIdle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuIdle = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIowait", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuIowait = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuHintr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuHintr = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSintr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSintr = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUser", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUser = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuNice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuNice = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSteal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSteal = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuGuest", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuGuest = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuGuestNice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuGuestNice = float64(math.Float64frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuFreqInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuFreqInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuFreqInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &CpuFreqInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuFreqInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuFreqInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuFreqInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSpeed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSpeed = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &MemoryInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemUtilization = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemTotal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemTotal = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUsed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemUsed = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemFree", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemFree = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemShared", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemShared = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemBuffers", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemBuffers = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCached", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemCached = float64(math.Float64frombits(v))
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &DiskInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Free = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReadBytes = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ReadTime = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reads", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Reads = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Total = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Used = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.UsedPercent = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBytes", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WriteBytes = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.WriteTime = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writes", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Writes = float64(math.Float64frombits(v))
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = &Tags{}
			}
			if err := m.Tags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &NetworkInfo{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BytesIn = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BytesOut = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PktsIn = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PktsOut = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuRtInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuRtInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuRtInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &CpuRtInfo{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuRtInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuRtInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuRtInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuUtilization = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSystem", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSystem = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIdle", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuIdle = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuIowait", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuIowait = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuHintr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuHintr = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSintr", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSintr = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuFreqRtInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuFreqRtInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuFreqRtInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &CpuFreqRtInfo{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CpuFreqRtInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CpuFreqRtInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CpuFreqRtInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSpeed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuSpeed = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryRtInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryRtInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryRtInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &MemoryRtInfo{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryRtInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryRtInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryRtInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemUtilization = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemTotal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemTotal = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUsed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemUsed = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemFree", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemFree = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemShared", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemShared = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemBuffers", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemBuffers = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCached", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MemCached = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskRtInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskRtInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskRtInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &DiskRtInfo{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskRtInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskRtInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskRtInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskFree", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiskFree = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskTotal", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiskTotal = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUsed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiskUsed = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUtilization", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DiskUtilization = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field KbRead", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KbRead = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field KbWritten", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.KbWritten = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpsRead", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OpsRead = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpsWrite", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.OpsWrite = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkRtInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkRtInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkRtInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &NetworkRtInfo{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkRtInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkRtInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkRtInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BytesIn = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BytesOut = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsIn", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PktsIn = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PktsOut", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PktsOut = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitoringConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitoringConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitoringConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &MonitoringConfigInfo{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitoringConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitoringConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitoringConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &MonitoringConfigInfo{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonitoringConfigInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonitoringConfigInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonitoringConfigInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentInterval", wireType)
			}
			m.AgentInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectorInterval", wireType)
			}
			m.CollectorInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CollectorInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleInterval", wireType)
			}
			m.ScheduleInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScheduleInterval |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHostCount", wireType)
			}
			m.MaxHostCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHostCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentTtl", wireType)
			}
			m.AgentTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentTtl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallTelegrafRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallTelegrafRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallTelegrafRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McisId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McisId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SshKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SshKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbdragonfly(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCbdragonfly
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCbdragonfly(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCbdragonfly
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCbdragonfly
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCbdragonfly
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCbdragonfly
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCbdragonfly
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCbdragonfly        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCbdragonfly          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCbdragonfly = fmt.Errorf("proto: unexpected end of group")
)
